%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Plantilla de memoria en LaTeX para la ETSIT - Universidad Rey Juan Carlos
%%
%% Por Gregorio Robles <grex arroba gsyc.urjc.es>
%%     Grupo de Sistemas y Comunicaciones
%%     Escuela Técnica Superior de Ingenieros de Telecomunicación
%%     Universidad Rey Juan Carlos
%% (muchas ideas tomadas de Internet, colegas del GSyC, antiguos alumnos...
%%  etc. Muchas gracias a todos)
%%
%% La última versión de esta plantilla está siempre disponible en:
%%     https://github.com/gregoriorobles/plantilla-memoria
%%
%% Para obtener PDF, ejecuta en la shell:
%%   make
%% (las imágenes deben ir en PNG o JPG)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper, 12pt]{book}
\usepackage[T1]{fontenc}

\usepackage[a4paper, left=2.5cm, right=2.5cm, top=3cm, bottom=3cm]{geometry}
\usepackage{times}
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel} % Comenta esta línea si tu memoria es en inglés
\usepackage{url}
%\usepackage[dvipdfm]{graphicx}
\usepackage{graphicx}
\usepackage{float}  %% H para posicionar figuras
\usepackage[nottoc, notlot, notlof, notindex]{tocbibind} %% Opciones de índice
\usepackage{latexsym}  %% Logo LaTeX
%-------Paquete para comentarios---------%
\usepackage{verbatim}
%-------Paquete para figuras---------%
\usepackage{float}
\usepackage{graphicx}
%-------Paquete para ecuaciones---------%
\usepackage{amsmath, amsthm, amssymb}


\title{Memoria del Proyecto}
\author{Nombre del autor}

\renewcommand{\baselinestretch}{1.5}  %% Interlineado

\begin{document}

\renewcommand{\refname}{Bibliografía}  %% Renombrando
\renewcommand{\appendixname}{Apéndice}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PORTADA

\begin{titlepage}
\begin{center}
\begin{tabular}[c]{c c}
%\includegraphics[bb=0 0 194 352, scale=0.25]{logo} &
\includegraphics[scale=0.25]{img/logo_vect.png} &
\begin{tabular}[b]{l}
\Huge
\textsf{UNIVERSIDAD} \\
\Huge
\textsf{REY JUAN CARLOS} \\
\end{tabular}
\\
\end{tabular}

\vspace{3cm}

\Large
ESCUELA TÉCNICA SUPERIOR DE INGENIERÍA DE TELECOMUNICACIÓN

\vspace{0.4cm}

\large
Curso Académico 2019/2020

\vspace{0.8cm}

Trabajo Fin de Grado/Máster

\vspace{2.5cm}

\LARGE
HACIENDO PROGRAMABLE Y ESTABLE CON FPGA UN DRONE COMERCIAL

\vspace{3cm}

\large
Autor : Eloy Navarro Morales \\
Tutor : Dr. José María Cañas Plaza\\
Cotutor : Juan Ordoñez Cerezo
\end{center}
\end{titlepage}

\newpage
\mbox{}
\thispagestyle{empty} % para que no se numere esta pagina


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Para firmar
\begin{comment} 
\clearpage
\pagenumbering{gobble}
\chapter*{}

\vspace{-4cm}
\begin{center}
\LARGE
\textbf{Trabajo Fin de Grado/Máster}

\vspace{1cm}
\large
Título del Trabajo con Letras Capitales para Sustantivos y Adjetivos

\vspace{1cm}
\large
\textbf{Autor :} Nombre del Alumno/a \\
\textbf{Tutor :} Dr. Gregorio Robles Martínez

\end{center}

\vspace{1cm}
La defensa del presente Proyecto Fin de Carrera se realizó el día \qquad$\;\,$ de \qquad\qquad\qquad\qquad \newline de 20XX, siendo calificada por el siguiente tribunal:


\vspace{0.5cm}
\textbf{Presidente:}

\vspace{1.2cm}
\textbf{Secretario:}

\vspace{1.2cm}
\textbf{Vocal:}


\vspace{1.2cm}
y habiendo obtenido la siguiente calificación:

\vspace{1cm}
\textbf{Calificación:}


\vspace{1cm}
\begin{flushright}
Fuenlabrada, a \qquad$\;\,$ de \qquad\qquad\qquad\qquad de 20XX
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Dedicatoria

\chapter*{}
\pagenumbering{Roman} % para comenzar la numeracion de paginas en numeros romanos
\begin{flushright}
\textit{Dedicado a \\
mi familia / mi abuelo / mi abuela}
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Agradecimientos

\chapter*{Agradecimientos}
%\addcontentsline{toc}{chapter}{Agradecimientos} % si queremos que aparezca en el índice
\markboth{AGRADECIMIENTOS}{AGRADECIMIENTOS} % encabezado 

Aquí vienen los agradecimientos\ldots Aunque está bien acordarse de la pareja, no hay que olvidarse de dar las gracias a tu madre, que aunque a veces no lo parezca disfrutará tanto de tus logros como tú\ldots 
Además, la pareja quizás no sea para siempre, pero tu madre sí.
\end{comment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen

\chapter*{Resumen}
\pagenumbering{Roman}
%\addcontentsline{toc}{chapter}{Resumen} % si queremos que aparezca en el índice
\markboth{RESUMEN}{RESUMEN} % encabezado

Dada la expansión de los drones en distintas tareas de la actualidad y del uso de las FPGAs como núcleos de procesamiento, resulta natural mezclar dichos dispositivos para beneficio mutuo.
A lo largo de este proyecto se han diseñado distintos elementos software y hardware para permitirle a un conjunto de instrucciones ejecutadas en un ordenador, controlar por completo las operaciones y trayectoria de vuelo de un drone comercial. Este es capaz de obedecer las instrucciones de posición indicadas por el programa ejecutado, sin estabilización, control ni intervención humana de por medio. Para ello se han diseñado elementos tanto en tierra, como a bordo del drone, que dotan al sistema de control autónomo sobre el vehículo. El control puede realizarse desde cualquier ordenador a través de la instalación de un paquete de librerías y la posterior ejecución de un programa en java. Todo el sistema se ha diseñado en base a FPGAs y software libres, drones de bajo coste y electrónicas concretas para cubrir cada tarea. De esta manera se dispone del control completo sobre el sistema diseñado, permitiendo mejoras y modificaciones futuras sin necesidad de incurrir en elevados costes de adquisición de software o hardware.
Tras el diseño de los distintos elementos se han realizado verificaciones de cada elemento por separado, integración y posterior verificación del sistema en su conjunto, mediante pruebas experimentales. Se han conseguido resultados especialmente satisfactorios con los sistemas en bucle cerrado, tanto en la estabilización como en el control del drone escogido.


%\begin{itemize}
%  \item ¿De qué va este proyecto? ¿Cuál es su objetivo principal?
%  \item ¿Cómo se ha realizado? ¿Qué tecnologías están involucradas?
%  \item ¿En qué contexto se ha realizado el proyecto? ¿Es un proyecto dentro de un marco general?
%\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen en inglés

\chapter*{Summary}
%\addcontentsline{toc}{chapter}{Summary} % si queremos que aparezca en el índice
\markboth{SUMMARY}{SUMMARY} % encabezado

Here comes a translation of the ``Resumen'' into English. 
Please, double check it for correct grammar and spelling.
As it is the translation of the ``Resumen'', which is supposed to be written at the end, this as well should be filled out just before submitting.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ÍNDICES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Las buenas noticias es que los índices se generan automáticamente.
% Lo único que tienes que hacer es elegir cuáles quieren que se generen,
% y comentar/descomentar esa instrucción de LaTeX.

%%%% Índice de contenidos
\tableofcontents 
%%%% Índice de figuras
\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de figuras} % para que aparezca en el indice de contenidos
\listoffigures % indice de figuras
%%%% Índice de tablas
%\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de tablas} % para que aparezca en el indice de contenidos
%\listoftables % indice de tablas


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INTRODUCCIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Introducción}
\label{chap:Introducción} % etiqueta para poder referenciar luego en el texto con ~\ref{sec:intro}
\pagenumbering{arabic} % para empezar la numeración de página con números

El desarrollo de este trabajo fin de grado está orientado a crear la infraestructura necesaria para comandar un dron mediante un conjunto de instrucciones. El sistema lo compondrán un dron, una estación de tierra y un PC. Como se ha hecho en diseños previos \cite{ordonez2019control}, se ha escogido una FPGA para el núcleo de procesamiento, ubicado en la estación de tierra.
\\
En la actualidad se ha extendido con rapidez el uso de drones y FPGAs más allá del entorno militar, en distintas áreas como vigilancia, cine, ocio, sistemas industriales, etc... Ambos dispositivos se han popularizado debido a su potencia y versatilidad de uso. La capacidad de control y guiado sobre el vehículo y su carga útil resultan tareas fundamentales, llevadas a cabo habitualmente de diversas maneras. Guiado mediante imagen \cite{DroneImagen}, tele-dirección, ubicación global y controles abiertos o por posición son algunos métodos comunes. Este trabajo se centra en el control por posición del vehículo y su guiado mediante instrucciones prefijadas. Dicho sistema ejecutará bucles de control que puede realizarse mediante distintos dispositivos, entre ellos, FPGAs \cite{ordonez2018tfg}. Ciertas características las convierten en una elección sólida como núcleo del sistema de estabilización y dirección para los múltiples grados de libertad del drone. En este TFG se hace uso de un cuadricóptero comercial como dron y FPGAs libres para cubrir las tareas de control y estabilización, fomentando además el uso y propagación de código abierto.\\
A continuación, se introducen algunas características de ambos dispositivos.


\section{Drones}
\label{sec:Sistemas básicos del drone}

Un dron hace referencia a una aeronave voladora no tripulada. Estas pueden ser pilotadas de manera remota, o mediante controles automáticos, dotándolas de distintos elementos según el mecanismo de control escogido y la tarea a cubrir.\\
Este trabajo hace uso de un cuadricóptero comercial X5C del fabricante Syma. Por tanto se mencionan algunos sistemas propios de los cuadricópteros que no se encuentran presentes necesariamente en otros tipos de drones. Algunos sistemas son específicos de cada aplicación, como puedan ser los estabilizadores de cámara usados en aplicaciones de grabación de video. Otros, por el contrario, son comunes a todos los cuadricópteros, como la estructura, sensores, electrónica de control, drivers de motores, motores y sistemas de gestión y almacenamiento de energía (baterías y reguladores). Además existen sistemas que si bien no son estrictamente necesarios para todas las aplicaciones, rara vez se ven excluidos, como son los sistemas de comunicaciones. Procedemos a comentar algunos de estos componentes del dron a continuación.


\subsection{Estructura}
\label{subsec:Estructura}

La estructura base o marco de un dron es donde apoyan y montan el resto de componentes. Sus principales requisitos son: amortiguar vibraciones, ser extremadamente rígida y ligera. Si las vibraciones no se viesen adecuadamente atenuadas, ciertas frecuencias podrían resonar mecánicamente a lo largo de toda la estructura, viendo comprometida la estabilidad del dron. Por su lado, la rigidez es fundamental, ya que para un adecuado control del dron, se necesita asumir independencia de ejes. Si partimos de una situación estable, por ejemplo, con el dron en vuelo a 1 metro de altura; si los cuatro motores generan el mismo impulso adicional (asumiéndolos ideales), en una estructura totalmente rígida el dron sencillamente ascendería. El par de rotación de las cuatro aspas se cancelaría entre sí, en caso de establecer el sentido de giro como muestra la Figura~\ref{fig:Drone}.

\begin{figure}[h]
	\centering
		\includegraphics[width=5cm, keepaspectratio]{Imagenes/Cuadricoptero_Pequeno_aspas.jpg}
		\caption{Sentido de rotación en cuadricóptero}
	\label{fig:Drone}
\end{figure}

En caso de que la estructura no resulte idealmente rígida; durante el empuje ascendente, se producirían momentos idénticos (M1, M2, M3 y M4 de la Figura \ref{fig:Drone_error}) sobre los cuatro motores, pero los ejes que unen dichos motores al marco sufrirían torsiones desiguales, lo que forzaría al dron a girar sobre sí mismo.

\begin{figure}[h]
	\centering
	\includegraphics[width=7cm, keepaspectratio]{Imagenes/Mot_Mom.png}
	\caption{Fuerzas asociadas a motores en dron}
	\label{fig:Drone_error}
\end{figure}

Dicho error de rotación podría ser corregido por otros sistemas del dron, pero solo pueden corregirse hasta cierto punto, además de ocupar dichos sistemas en corregir errores que la propia estructura puede paliar si se construye adecuadamente, pudiendo llegar a saturarlos e impedirles realizar su tarea adecuadamente.


\subsection{Sensores}
\label{subsec:Sensores}

Parte fundamental de todo cuadricóptero es un conjunto de sensores capaz de medir aceleraciones y giros. Para la mayoría de los drones comerciales, incluido el utilizado en este TFG, se hace uso de acelerómetros y giróscopos MEMS \cite{ganssle2012designer}, es decir elementos mecánicos y electromecánicos miniaturizados e integrados en solo chip. Por ejemplo un giróscopo y acelerómetro MEMS es en realidad un capacímetro diferencial conectado a un conjunto de láminas intercaladas, unas fijas al sustrato y otras libres como se muestra continuación en la Figura~\ref{fig:Masa_ST}.

\begin{figure}[h]
	\centering
	\includegraphics[width=9cm, keepaspectratio]{Imagenes/Acel_Giros_MEMS.jpg}
	\caption{Masa y capacímetros de STMicroelectronics}
	\label{fig:Masa_ST}
\end{figure}

Cuando se produce una aceleración sobre el chip, las láminas fijas al sustrato se desplazan con él, acercándose a ciertas láminas libres y alejándose de las demás, viendo por tanto su medida diferencial de capacidad alterada de manera proporcional a la aceleración, en base a la segunda ley de Newton. Esta construcción se realiza para cada eje y se integra en un solo chip, a menudo llamada plataforma inercial de tres ejes. De esta manera se facilita su integración en el sistema y se abaratan costes.\\
Como en todo, hay calidades que definen las capacidades finales de un sistema. Para el caso de una plataforma inercial la resolución es un parámetro fundamental, tanto en la medida de las aceleraciones como de los giros.\\
Podemos ilustrar el error de desplazamiento asociado a dichos sensores, cuando el sistema de control de dron se basa, por ejemplo, en un giróscopo incapaz de detectar cierto nivel de giro. Es decir, una velocidad de giro suficientemente lenta y constante como para quedar por debajo del salto mínimo de velocidad angular que el sensor es capaz de resolver, produciría un giro indetectable y por tanto incorregible para el dron. Como para el caso de la estructura, dicho error también podría ser corregido por otro tipo de sensor, pero a menudo estos no se instalan, debido al incremento del coste. Para esta situación, por ejemplo, un sensor que aplicase una posible solución sería un magnetómetro a modo de brújula, corrigiendo errores de giro mediante orientación global. Ningún dron de los utilizados en este TFG integra sistema adicional para la corrección del giro, además del propio giróscopo.


\subsection{Electrónica de Control}
\label{subsec:Electrónica de Control}

Este módulo es el encargado de procesar las señales de los sensores, entregando las respuestas necesarias para cubrir dos tareas; estabilizar el dron en giro y plano horizontal y en caso de recibir comandos por radio u otro mecanismo, modificar las órdenes a entregar a los sistemas de actuación, para obedecer. Para el caso de los cuadricópteros objeto de este trabajo, los elementos de actuación son cuatro motores, y esta electrónica deberá cubrir ambas tareas, estabilización y modificación del comportamiento en base a comandos radio recibidos desde la estación de tierra.\\
En una situación de vuelo estable, el objetivo de esta electrónica es corregir las aceleraciones y giros con las órdenes adecuadas a los motores. Por ejemplo, si un sensor detecta una aceleración a izquierdas, esta electrónica deberá responder generando una fuerza en sentido contrario, para este caso, consistirá en inclinar el dron ligera y proporcionalmente a derechas. Para ello entregará mayor indicación de velocidad de giro a los drivers de los motores izquierdos, y menor a los derechos. Con esto el dron se inclinaría, corrigiendo la aceleración que de otro modo le hubiera desplazado hacia la izquierda. Este es un caso muy simplificado a modo de ejemplo. La electrónica a bordo computa las ecuaciones de movimiento para el cuadricóptero \cite{Quad_ecuations} a la frecuencia que le permite su capacidad de proceso, junto con los tiempos de adquisición de los sensores y respuesta de los drivers y motores.


\subsection{Drivers y motores}
\label{subsec:Drivers y motores}

Este hardware es el encargado de convertir las órdenes de velocidad de giro, en giro real de las aspas conectadas a los motores. Cubren la función de transductores, instrucción a fuerza, a través de etapas de potencia que dependen de la construcción de los motores. La estructura general desde el controlador, hasta los motores, se muestra en la Figura~\ref{fig:Drivers_gen}.

\begin{figure}[h]
	\centering
	\includegraphics[width=16cm, keepaspectratio]{Imagenes/Drone_Drivers_Block.png}
	%\includegraphics[]{Imagenes/Drone_Drivers_Block.png}
	\caption{Bloques Hardware del sistema de control y drivers de un cuadricóptero}
	\label{fig:Drivers_gen}
\end{figure}

Los motores pueden ser basados en escobillas, o libres de ellas. Cada tipo de motor tiene una forma concreta de ser controlado \cite{Infi_Motors}. Los que disponen de escobillas, se manejan mediante métodos de control de motores de corriente continua. Por tanto las etapas de potencia de los drivers se despreocupan de la posición del rotor respecto del estator y transmiten mayor o menor cantidad de corriente al bobinado, a través de puentes en H controlados por PWM. Para el caso de un motor sin escobillas, hay múltiples métodos de control para producir el giro. La dificultad reside en saber en qué instante y a qué velocidad se puede variar el campo magnético en las tres fases del motor. Para ello hay algunos sistemas basados en conocer la posición relativa entre el rotor y el estator mediante sensores de efecto hall. Otros sistemas en cambio, trabajan sin dichos sensores. A efectos de este TFG, todos los motores son de corriente continua.


\subsection{Comunicaciones}
\label{subsec:Comunicaciones}

Dependiendo del tipo de dron, no es estrictamente necesario disponer de un sistema de comunicaciones radio, ya que puede ser sustituido por un conjunto de instrucciones a ejecutar a bordo del dron, sin necesidad de ver su comportamiento modificado durante el vuelo. Pero tanto para el caso de drones teledirigidos, como para el de este TFG, la radio es un componente fundamental, encargada de comunicar la electrónica del dron, con la electrónica en tierra que tiene por objetivo dirigir el dron.
Aquí rigen múltiples tipos de sistemas y estándares, el más común se encuentra en banda libre de 2.4Ghz y es en el que se apoya este TFG. Se envían comandos radio digitales en forma de tramas de doce paquetes, siendo cada paquete un canal del dron. Los cuatro canales comunes a todo dron, y utilizados en esta trabajo son: Altura (-Uz), cabeceo (pitch), guiñada (yaw) y alabeo (roll) ordenados como se muestra en la Figura~\ref{fig:YawPitchRoll}.

\begin{figure}[h]
	\centering
	%\includegraphics[]{Imagenes/Yaw-pitch-roll-Quadcopter.png}
	\includegraphics[width=12cm, keepaspectratio]{Imagenes/Yaw-pitch-roll-Quadcopter.png}
	\caption{Altura (Uz), cabeceo (pitch), guiñada (yaw) y alabeo (roll)}
	\label{fig:YawPitchRoll}
\end{figure}


\section{Aplicaciones de vehículos aéreos no tripulados}
\label{sec:Aplicaciones}

Un dron tal y como lo conocemos actualmente es una aeronave que vuela sin tripulación. Las aplicaciones de los drones son muchas, desde su inicio en el sector militar, como muchas otras tecnologías, se ha extendido su utilización a áreas de otros sectores para cubrir tareas variadas. A continuación se mencionan algunos casos interesantes.


\subsection{Agricultura}
\label{subsec:Agricultura}

Una de las áreas con mayor impacto en el desarrollo y aplicación esta siendo el sector agrícola. Con hectáreas de cultivos que controlar, y cada vez más tipos de sensores, se utilizan desde control de plagas, hasta por ejemplo, exploración de viñedos para determinar el mejor momento para la vendimia. A menudo hacen uso de controladores basados en ubicación global a través de GPS para el control de posición y trayectoria del dron, y de sensores ópticos y multiespectrales para determinar parámetros como la actividad clorofílica o su estrés hídrico. Este es el caso del sensor Sequoia+ de Parrot \cite{parrot2019parrot} de la Figura~\ref{fig:Sequo}. Dicho sensor se monta a bordo del dron que vaya a realizar la misión.
\begin{figure}[h]
	\centering
	\includegraphics[width=10cm, keepaspectratio]{Imagenes/Parrot_Sequoia.jpg}
	%\includegraphics[width=12cm, keepaspectratio]{Imagenes/Yaw-pitch-roll-Quadcopter.png}
	\caption{Sensor óptico Sequoia+}
	\label{fig:Sequo}
\end{figure}
De esta manera se analiza desde el cielo, por ejemplo, cuanta luz absorben y reflejan las plantas, permitiendo optimizar la producción del agricultor.


\subsection{Seguridad y rescate}
\label{subsec:Seguridad y rescate}

Debido a la ventaja de volar a alturas inferiores que las de un helicóptero, se ha extendido el uso de los drones al rescate de personas. Integrando cámaras de alta resolución en los mismos, y sistemas de localización de desaparecidos, como es el caso del proyecto de seguridad ``LifeSeeker'' \cite{Lifeseeker} de Centum se podría ubicar a personas desaparecidas. El dispositivo de la Figura~\ref{fig:Lifeseeker} ha sido diseñado para instalarse en aviones no tripulados \cite{Lifeseeker_Noticia}. El sistema embarcado hace uso de los móviles de los desaparecidos, aun fuera de las zonas de cobertura, como si se tratasen de radiobalizas, permitiendo así su localización.

\begin{figure}[h]
	\centering
	\includegraphics[width=10cm, keepaspectratio]{Imagenes/LifeSeeker.png}
	%\includegraphics[width=12cm, keepaspectratio]{Imagenes/Yaw-pitch-roll-Quadcopter.png}
	\caption{Módulo LifeSeeker de Centum}
	\label{fig:Lifeseeker}
\end{figure}

Otros ejemplos de sistemas basados en drones, los han utilizado para reparto masivo de medicamentos o incluso envíos de sangre para transfusiones \cite{Envio_Sangre_drone}.


\subsection{Envíos}
\label{subsec:Envios}

En esta aplicación, ha habido controversia relacionada con el control aéreo. La legislación actual dificulta el desarrollo en esta industria a la misma velocidad que se han expandido los drones en otras áreas. No obstante empresas como DHL o Amazon han desarrollado tecnologías al respecto \cite{Drone_env} y las han probado e implantado en zonas en las que dichas limitaciones no funcionan de la misma manera. A través de este servicio, Amazon envían paquetes en tiempo inferiores a los 30 minutos usando drones como el de la Figura~\ref{fig:AmaDrone}. Son sistemas híbridos con despegue vertical y vuelo horizontal. Gozan de navegación autónoma guiada por GPS y controlan el espacio aéreo a su alrededor mediante visión artificial, para evitar obstáculos y localizar su área de aterrizaje.

\begin{figure}[h]
	\centering
	\includegraphics[width=12cm, keepaspectratio]{Imagenes/prime-air_04.jpg}
	%\includegraphics[width=12cm, keepaspectratio]{Imagenes/Yaw-pitch-roll-Quadcopter.png}
	\caption{dron de Amazon en prueba real de envío}
	\label{fig:AmaDrone}
\end{figure}


\section{FPGA}
\label{sec:FPGA}

Las siglas hacen referencia a un array de puertas lógicas reprogramables in situ (Field Programmable Gate Array). Son la evolución de una tecnología previa similar llamada CPLD, que gracias a una reordenación de los elementos que las componían, consiguen una mayor densidad de puertas lógicas por centímetro cuadrado.\\
Una FPGA es un dispositivo que agrupa elementos capaces de realizar pequeñas operaciones lógicas y almacenar sus resultados en biestables. Dichas operaciones lógicas y memorias pueden interconectarse de manera muy flexible, permitiendo llevar a cabo operaciones y tareas mucho más complejas. Su programación se realiza a través de lenguajes de descripción de hardware, orientados a trabajar a bajo nivel. Para el caso de este trabajo se ha hecho uso de Verilog 2001. Un lenguaje similar a C en aspecto, pero con un concepto de fondo radicalmente distinto. A continuación se comentan algunas características y aplicaciones actuales de las FPGAs.

\subsection{Características}
\label{subsec:Características}

Una FPGA dispone de ciertas características que le ofrecen ventaja sobre opciones programables más tradicionales, como procesadores secuenciales. Estas pueden ser programadas de tal manera que ejecuten un conjunto de instrucciones concreto varias veces en paralelo, sin ver disminuido su rendimiento global, ni impactar en otros módulos pre-programados. Para un procesador secuencial, realizar la misma tarea dos veces, supone esperar a que la primera acabe para ejecutar la segunda, o disponer de hardware dedicado por duplicado, construido sobre el mismo silicio, opción no siempre disponible. Una FPGA, en cambio, es capaz de construir el mismo sistema hardware tantas veces como recursos hardware disponga, permitiendo que todos ellos ejecuten en paralelo, con un detrimento del rendimiento mínimo y controlable. Esta ventaja es de especial importancia en procesos de control cuya tarea puede dividirse en muchas, como en procesamiento de imágenes, o sistemas de procesado digital de señales. El segundo caso está muy relacionado con este TFG, debido a la ejecución simultanea de múltiples sistemas de comunicaciones, junto con cuatro bucles de control PID paralelos.\\
Otra potente característica es su capacidad de re-configuración dinámica. Esta les ha otorgado popularidad en aplicaciones en las que se requiere rediseñar por completo el sistema de procesado, sin necesidad de un cambio físico sobre el hardware. Permiten modificar, por ejemplo, un filtro completo, no solo el valor de sus coeficientes; o reordenar los módulos de un sistema de telecomunicaciones, dotándolo de funciones completamente diferentes en base a una arquitectura radicalmente nueva. Características como esta hacen que estos dispositivos se popularicen para nuevas aplicaciones.

\subsection{Aplicaciones}
\label{subsec:Aplicaciones}

Como se ha mencionado antes, las FPGAs cubren un espectro muy grande de aplicaciones, ya que van desde las típicas sustituciones de sistemas digitales combinacionales, a núcleo de sistemas paralelos, en ocasiones inabordables para un procesador secuencial estándar.\\
Algunas aplicaciones potentes a día de hoy para FPGAs son, por ejemplo, la visión artificial, procesos industriales o procesador de redes neuronales \cite{FPGAs_Neurals}. Estos últimos a menudo se han llevado a cabo por procesadores gráficos que, en su esencia, son una mezcla de muchos pequeños procesadores pensados para realizar cómputos geométricos simples. En ocasiones se están sustituyendo por FPGAs debido a la flexibilidad, potencia y capacidad de re-configuración de las mismas \cite{zhu2003fpga}. Los avances en unidades de procesamiento gráfico, a menudo no alcanzan a cubrir las necesidades de dichas redes y  dispositivos FPGA equivalentes en potencia, suelen disponer de mayor eficiencia energética y facilidad para el clustering.\\
Gracias a su robustez son también utilizadas en entornos de seguridad como los ferroviarios, e incluso comienzan a invadir entornos menos comunes, como el espacial.


\subsection{FPGAs Libres}
\label{subsec:FPGAs Libres}

Son aquellas en las que se encuentra disponible toda la información de su diseño interno, formatos de almacenamiento de datos (BitStream) y en general todo aquello necesario para que un diseñador sea capaz de crear las herramientas de software necesarias para programar dichos dispositivos.\\
En la actualidad muchas de las herramientas de diseño software para FPGAs son software propietario con un elevado coste de adquisición. Sobre todo aquellas versiones de los entornos integrados de desarrollo que incluyen la mayor cantidad de comodidades, módulos IP pre-compilados y herramientas posibles. Este es el caso de Quartus, distribuido por Intel para sus FPGAs, que incluye una versión gratuita, muy limitada de prestaciones y capacidades, o Vivado de Xilinx, en una situación similar. En contraposición a este tipo de software se encuentra el software libre, o abierto, en general englobado bajo licencias GPL (General Public License) que tienen por objetivo defender su libre distribución sin necesidad de adquirir licencias de pago. Bajo este tipo de licencias se encuentra software como Icestudio (Figuras~\ref{fig:icelogo}), orientado al diseño de software para FPGAs de Lattice, en entornos gráficos con editor de texto, o esquemas de bloques como en la Figura \ref{fig:icestudio}, en constante crecimiento. Una de las familias de FPGAs recientemente cubiertas por este software son las ICE40 UltraPlus, concretamente la ICE40UP5K. Esta FPGA es la utilizada para desarrollar el procesador de la estación de tierra durante el desarrollo de este TFG, que se detallará más adelante en este informe.

\begin{figure}[h]
	\centering
	\includegraphics[width=12cm]{Imagenes/Ice_Studio_Logo.png}
	%\includegraphics[width=12cm, keepaspectratio]{Imagenes/Yaw-pitch-roll-Quadcopter.png}
	\caption{Logo de Icestudio, IDE para desarrollo de software en FPGAs libres}
	\label{fig:icelogo}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[width=12cm]{Imagenes/Ice_Studio_IDE.png}
	%\includegraphics[width=12cm, keepaspectratio]{Imagenes/Yaw-pitch-roll-Quadcopter.png}
	\caption{Captura del entorno Icestudio}
	\label{fig:icestudio}
\end{figure}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OBJETIVOS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage % empezamos en página impar


\chapter{Objetivos}
\label{chap:objetivos}

Habiendo ubicado los elementos principales con los que se trabajará durante este desarrollo, procedemos a concretar y comentar el objetivo del TFG. Adicionalmente, los subobjetivos pretenden desgranar el objetivo principal en logros más concretos, que juntos, permitirán alcanzar el objetivo principal.

\section{Objetivo principal}
\label{sec:objetivo-ppal}

En este trabajo, se pretende estabilizar y programar el control de un dron comercial de bajo coste haciendo uso de FPGAs libres. El sistema; deberá ser capaz de estabilizar el vehículo de manera autónoma, haciendo uso de electrónica de sensorización embarcada en el dron y computación sobre la FPGA en tierra. Adicionalmente, el dron deberá obedecer las instrucciones de movimiento ejecutadas en el PC, en comunicación con la FPGA.


\section{Sub-objetivos}
\label{sec:Sub-objetivos}

A continuación se enumeran los tres objetivos cuyas funcionalidades, en conjunto, permitirán alcanzar el objetivo principal.

\subsection{Enriquecer dron comercial}
\label{subsec:Enriquecer dron comercial}

Se deberá nutrir al vehículo con los elementos de sensorización y comunicación adecuados a la tarea. Estos deberán permitirle conocer su ubicación de manera local y establecer una comunicación con la estación de tierra, donde se ubicará la FPGA que computará y comunicará las correcciones pertinentes de vuelta.

\subsection{Estabilizar dron mediante FPGA en tierra}
\label{subsec:Estabilizar dron mediante FPGA en tierra}

Una vez diseñada la estación de tierra y establecida la comunicación con los controladores y sensores a bordo del dron, se procederá a construir el software necesario para conseguir un vuelo estacionario y estable del vehículo.

\subsection{Programar dron desde PC}
\label{subsec:Programar dron desde PC}

La estación de tierra deberá comunicarse con el PC, permitiendo a este último ejecutar instrucciones que afecten a los controladores ejecutados en la FPGA de la estación. De esta manera, el PC se convertirá en el ordenador de mando indirectamente. Este ejecutará las instrucciones que comandarán los movimientos del dron, siendo la FPGA en la estación de tierra, la encarga de que el vehículo obedezca dichas ordenes de manera estable.


\section{Requisitos}
\label{sec:Requisitos}

Los objetivos del trabajo se deberán cubrir con unos requisitos mínimos. Estos permitirán discernir cuando una tarea se ha cumplido adecuadamente para avanzar a la siguiente. Para ello se listan a continuación.

\begin{itemize}
  \item El sistema deberá ser capaz de estabilizar el dron con al menos tres grados de libertad; cabeceo, alabeo y altitud.
  
  \item Cada grado de libertad controlado deberá implementar un bucle cerrado, retroalimentado, con controlador PID.
  
  \item Dichos controladores deberán obedecer a consignas radio que permitan el control en tiempo real desde la plataforma en tierra.
  
  \item Para facilitar las tareas de estabilización y otorgar flexibilidad al sistema, los controladores PID deberán disponer de parámetros re-configurables también desde la estación de tierra.
\end{itemize}

Para cubrir estos requisitos, se han planteado una metodología y un plan de trabajo a seguir, comentados a continuación.

\section{Metodología}
\label{sec:Metodología}

Para realizar el seguimiento del trabajo, se intentarán tener reuniones semanales por conferencia, informando de los avances y posibles problemas. También se informará por correo u otros medios en caso de resultar útil. En estas reuniones se comentará el avance y problemas y se propondrán posibles soluciones y siguientes tareas a abordar.\\
El trabajo se organizará segmentando el objetivo semanal en tareas más simples. Se diseñarán soluciones para dichas tareas y posteriormente se implementarán y testearán. Según los resultados de los ensayos, se corregirán errores, se buscarán y aplicarán soluciones alternativas y se volverá a ensayar. En caso de resultado positivo, se preparará el resultado para informar adecuadamente en la reunión, y recibir información de vuelta.


\section{Plan de trabajo}
\label{sec:Plan de trabajo}

Para conseguir alcanzar el objetivo final, cubriendo los requisitos mínimos, se procederá a abordar el trabajo con la siguiente ordenación de tareas:

\begin{itemize}

  \item Enlace con el dron: Se trara del punto de partida del proyecto. Pasa por ser capaces de realizar una comunicación radio entre un ordenador y el propio dron. Para esta tarea se hará uso del software libre provisto por goebish en su repositorio nrf24\_multipro. Habrá que conseguir enlazar el software ejecutado en un procesador de Atmel, con la electrónica propia del dron.
  
  \item Comunicación de órdenes fijas al drone: Una vez establecida la comunicación es el momento de generar el software necesario tanto para el procesador de Atmel como para la FPGA. Con esto se podrán probar instrucciones fijas, simples hacia el dron, por ejemplo una prueba de arranque, enciende y apaga motores.
  
  \item Diseño de librerías de control para PC: El objetivo de las librerías, es facilitar el uso del dron y la repetitividad de los ensayos a través de abstraerse de la capa más baja del control del dron. Esto permite pasar de instrucciones simples e independientes, a instrucciones complejas, compuestas a su vez de secuencias de instrucciones simples. Por ejemplo, despegue y aterrizaje, giros o desplazamientos. Esto facilitará las siguientes tareas.
  
  \item Comando del dron en bucle abierto: En este punto ya se dispone del software para realizar ensayos de vuelo con el dron en bucle abierto. Se encadenarán varias instrucciones de vuelo construidas en la librería previa, con el objetivo de probar el dron en trazados más complejos. Como despegue, avance, retorno y aterrizaje, o estabilidad en vuelo estático.
  
  \item Diseño de electrónica de a bordo: Para poder corregir el comportamiento en vuelo del dron, será necesario que este disponga de información relativa a su posición local. Para cubrir esta tarea, se instalará en el dron electrónica capaz de medir parámetros de posición y transmitirlos a la estación de tierra para ser procesados.
  
  \item Diseño de la estación de tierra: Para proceder a realizar ensayos de bucle cerrado, será necesario tener disponible una electrónica en tierra capaz de recibir las medidas de los sensores de a bordo. Deberá entonces poder procesarlas y transmitir la respuesta hacia el vehículo. Dicha respuesta dependerá tanto de las medidas de los sensores del dron, como de las indicaciones recibidas desde el ordenador de mando.
  
  \item Cierre de bucles para cada eje: Se deberán diseñar bucles de control independientes para cada eje en la FPGA de la estación de tierra. Esto permitirá la estabilización y manejo completo del dron.
  
  \item Experimentación y parches: Este punto cubre una necesidad presente en cada tarea. Tras aplicar cambios software y/o hardware se testeará el trabajo. Según el resultado, se avanzará a la siguiente fase del desarrollo, o se iterará entre la fase de origen y esta, hasta corregir adecuadamente los posibles errores.
  
\end{itemize}

Estas tareas se llevarán a cabo en gran medida los fines de semana, añadiendo horas tras el horario laboral, dependiendo de la disponibilidad. 
Para cubrir las tareas, se hará uso de las herramientas de desarrollo disponibles, comentadas a continuación en el Capítulo~\ref{chap:Infraestructura utilizada}. En base a estas, se planteará una arquitectura de sistema, definida más adelante en la Sección~\ref{sec:Arquitectura del sistema}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INFRAESTRUCTURA UTILIZADA %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage % empezamos en página impar
\chapter{Infraestructura utilizada}
\label{chap:Infraestructura utilizada}

Para alcanzar los objetivos, desarrollando las tareas comentadas anteriormente, hemos utilizado un amplio conjunto de herramientas software y hardware. Estas nos han permitido realizar diseños software en distintos lenguajes, compilar, programar y ejecutar, en las plataformas disponibles. Posteriormente, mediante el uso de herramientas adicionales, se han podido simular y evaluar los resultados, permitiendo avanzar a través de tareas de depuración y corrección de errores. A continuación se describen dichas herramientas y su uso durante este trabajo.


\section{Entornos de desarrollo}
\label{sec:Entornos de desarrollo}

En este apartado, se comentan las herramientas software que permiten trabajar con código, cubriendo múltiples necesidades (edición, compilación, enlazado, etc...) en un solo paquete.

\subsection{IceCube2}
\label{sec:IceCube2}

En su versión 2017.08.27940, es el entorno de desarrollo suministrado por Lattice para la programación de sus familias de pequeñas FPGAs. Integra un editor de texto plano, junto con un sintetizador para código Verilog 2001. También realiza las tareas de ubicación de elementos lógicos utilizados, trazado de conexiones en el array de la FPGA escogida y generación del fichero de programación ``*.bin''. Se ha utilizado durante todo el desarrollo sobre FPGA del trabajo. Con él se han realizado todas las tareas desde la compilación del proyecto completo hasta la generación del fichero de programación.

\subsection{Quartus Prime}
\label{sec:Quartus Prime}

Versión 15.1.0 Build 185. Herramienta de diseño, test, depuración y programación de software para FPGAs de Altera (Intel). Utilizado en este trabajo exclusivamente por su editor de texto con reconocimiento del leguaje Verilog 2001 e identificación de estructuras con color. La comodidad y versatilidad de su editor integrado, frente al entorno de Lattice, lo han convertido en mi elección para el desarrollo del código de cada módulo, previo a su compilación en el proyecto, tarea realizada con el IDE de Lattice.

\subsection{Arduino IDE}
\label{sec:Arduino IDE}

Versión 1.8.8. Entorno de desarrollo integrado de Arduino para procesadores Atmel compatibles. Adicionalmente al editor de texto, compilador, enlazador y programador, suministra algunas herramientas adicionales de utilidad:
Instalador de librerías integrado. Utilizado en el TFG para facilitar la instalación de paquetes de comunicación por puerto serie y manejo de dispositivos desde librerías en Github. Entre los incluidos, se hace uso en este trabajo de las librerías para puertos serie SPI, I2C y UART y librerías para manejo de sensores.
Además incluye un monitor de puerto serie ya configurado para el dispositivo concreto a programar. Realiza la lectura por el mismo puerto USB utilizado para programar el dispositivo, ahorrando tiempo y disminuyendo el peso necesario en la electrónica de a bordo para realizar tareas de diagnóstico. Este entorno se ha utilizado mayoritariamente para el desarrollo, depuración y programación de los programas ejecutados en los procesadores Atmel ubicados a bordo del dron (comunicación y sensores) y en la estación de tierra (comunicación por radio).


\section{Herramientas de Simulación}
\label{sec:Herramientas de Simulación}

En este apartado se comenta la única herramienta de simulación utilizada en el proyecto, ModelSim. Versión 10.4b. Herramienta para la simulación de lenguajes de descripción de hardware en general. Compatible con Verilog 2001, permite la comprobación de sintaxis del lenguaje, compilación e instanciación de múltiples módulos. En cuanto a la simulación utilizada, es una herramienta flexible en la creación de cronogramas y selección de señales a observar. Ofrece también completa configuración de resoluciones y tiempos de simulación, junto con la posibilidad de realizar análisis dinámicos del hardware definido. Gracias a su uso, se ha ahorrado tiempo a la hora de realizar tareas de limpieza de código y pruebas fuera del vehículo, disminuyendo el tiempo de desarrollo y la cantidad de choques por errores de diseño en los controles de vuelo.


\section{Herramientas de programación}
\label{sec:Herramientas de programación}

Una vez generados y simulados los códigos, estos deben ser programados en los distintos dispositivos que componen el sistema. La programación de los procesadores de Atmel se realiza a través del propio entorno de desarrollo comentado anteriormente en el apartado \ref{sec:Arduino IDE}, el resto de herramientas necesarias para programación se comentan a continuación.

\subsection{FT\_Prog}
\label{sec:FT_Prog}

Versión 3.6.88.402. Herramienta distribuida por FTDI Chip para reconfigurar la memoria flash de los dispositivos de comunicación USB, que permite modificar el comportamiento de cada canal de sus dispositivos; activando, desactivando o modificando su comportamiento para hacerlo acorde a distintos estándares. Se ha utilizado para configurar los dos canales de comunicación USB de la estación de tierra. Configurando el canal A para permitir la programación del dispositivo FPGA y el canal B para comunicar, FPGA con PC mediante USB.

\subsection{Diamond Programmer}
\label{sec:Diamond Programmer}

Se trata de la herramienta de programación distribuida por Lattice. Versión 3.10.0.111.2. Permite la programación de sus dispositivos FPGA mediante el uso de ficheros con formato ``.bin'' generados tras el trazado de la FPGA. Dicho fichero es generado, en este TFG, por la herramienta IceCube2 \ref{sec:IceCube2} y posteriormente cargado con este software para programar la FPGA de la estación de tierra.


\section{Herramientas de depuración}
\label{sec:Herramientas de depuración}

Para facilitar la detección y corrección de errores, se ha utilizado una herramienta de análisis de señales digitales, compuesta de un elemento hardware y otro software. A continuación se describen ambos.

\subsection{Logic Analizer}
\label{sec:Logic Analizer}

Tarjeta de adquisición de Saleae. Trabaja como analizador lógico de ocho canales, con muestreo hasta 24MSPS, permite la adquisición y análisis de señales de hasta 12MHz. Sus ocho canales son reconfigurables como señales de entrada y señales de disparo, facilitando la sincronía con tramas y eventos. Esta herramienta trabaja en conjunto con la interfaz de usuario ``Logic'' \ref{sec:Logic}. Sus ocho conexiones se han realizado en distintos puntos de la estación de tierra. Su función durante el desarrollo ha sido poder obtener las capturas más representativas posibles de lo que estaba ocurriendo en cada momento. Para ello, se han capturando tramas desde el PC de mando hacia la estación de tierra, medidas de los sensores desde el dron hacia la estación de tierra, señales internas de la FPGA y órdenes desde la estación de tierra al dron. Este set de sondas, ha facilitado tanto el debug en vuelo, como la corrección de distintos parámetros de los controladores. Sin ellas, hubiera resultado imposible avanzar adecuadamente entre las etapas de desarrollo del TFG.

\subsection{Logic}
\label{sec:Logic}

Versión 1.2.10. Esta utilidad de Saleae es su interfaz para almacenamiento y visualización de señales medidas con sus herramientas de análisis digital. Para el caso de un puerto serie de comunicaciones, permite el análisis de la información para un protocolo concreto, interpretando la información en cada canal y mostrándola en relación al momento de lectura. Se pueden nombrar y configurar distintos protocolos para cada canal, de esta manera se puede utilizar para comprobar el comportamiento de señales concretas del sistema, o analizar los datos transferidos entre dispositivos. Esta herramienta facilita el debug del sistema a través de tareas de detección y corrección de errores.


\section{Plataformas hardware}
\label{sec:Plataformas hardware}

\subsection{Arduino Uno y Nano}
\label{sec:Arduino Uno y Nano}

Tarjetas de desarrollo que integran un procesador de Atmel de 8 bits modelos ATMEGA8U2-MU y ATMEGA328P-AU, un interfaz de UART a USB para comunicaciones y alimentación, conectores hacia los GPIOs de los procesadores y un regulador de 5V a 3V3. Se pueden alimentar de manera externa sobre la entrada del regulador, o directamente mediante el USB. Se dispone de acceso para programación y depuración a través del mismo USB.

\subsection{ICE40 UltraPlus Breakout Board}
\label{sec:ICE40 UltraPlus Breakout Board}

Tarjeta de desarrollo para la familia UltraPlus de ICE40. Incluye elementos varios de interfaz humana, como Leds, interruptores, jumpers e interfaz hacia los pines de propósito general, GPIOs. También incluye un interfaz USB reprogramable de FTDI Chip y doble canal, FT232HL. Como procesador hace uso de una FPGA ICE40UP5K-SG48, con 5280 celdas lógicas, 120Kbits de RAM embebida y 1024kbits de RAM estática, una PLL y 8 bloques DSP (multiplicadores de 16 bits).


\subsection{SYMA X5C}
\label{sec:SYMA X5C}

Dron cuadricóptero teledirigido fabricado por Syma. Un dron ligero para su tamaño, con una estructura robusta, perfecto para aprendizaje de principiantes y experimentación gracias a su importante resistencia mecnánica. Electrónica de recepción radio con 50 metros de alcance en la banda de 2.4GHz, cuatro canales de control, batería de litio, 31cm de ancho y largo, y 100gr de peso. Incluye una cámara con almacenamiento en SD-Card.

\subsection{NRF24L01}
\label{sec:NRF24L01}

Módulo que integra el chip de mismo código, con condensadores de desacoplo necesarios para su utilización, una antena integrada en la propia PCB y pines para acceso a su interfaz SPI. Ocupa la banda de 2.4GHz, con 125 posibles canales de 1 MHz de ancho de banda cada uno. Al trabajar entre 1.9V y 3.6, es perfecto para su utilización junto a tarjetas Arduino Uno y Nano, que integran reguladores con salida a 3.6V. Dispone de tasas de transferencia de hasta 2Mbps y alcances de hasta 30 metros.

\subsection{Flow breakout board}
\label{sec:Flow breakout board}

Se trata de un módulo de BitCraze que integra un sensor de medida de distancias por tiempo de vuelo VL53L0x accesible por I2C, junto a un sensor de flujo óptico PMW3901 accesible por SPI \cite{sensor_module}. Incluye electrónica periférica para hacerlos funcionar y un cabezal para las conexiones eléctricas. Al alimentarse a 3.6V puede ser conectado a la salida de los reguladores de las tarjetas de desarrollo de Arduino.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Drone enriquecido controlado por FPGA %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage % empezamos en página impar
\chapter{Dron enriquecido controlado por FPGA}
\label{Drone enriquecido controlado por FPGA}

\section{Arquitectura del sistema}
\label{sec:Arquitectura del sistema}

La arquitectura del sistema se ha planteado con el propósito de cubrir los objetivos propuestos en el Capítulo~\ref{chap:objetivos}, haciendo uso de la infraestructura disponible, mencionada en el Capítulo~\ref{chap:Infraestructura utilizada}. El sistema se compone de cuatro módulos principales y dos interfaces de alto nivel. Los cuatro módulos principales que lo componen son:

\begin{itemize}
  \item Un ordenador para enviar las órdenes de mando.
  
  \item Un dron como estructura base y sistema de vuelo con su propia electrónica para la recepción de órdenes de movimiento. La llamaremos electrónica del dron de aquí en adelante, para diferenciarla del siguiente conjunto de electrónica.
  
  \item Un conjunto de sensores para realizar medidas de posición y ubicar al dron. De ahora en adelante, sensores de a bordo o embarcados.
  
  \item Una estación de tierra como centro de control y verdadero centro neurálgico del sistema.
\end{itemize}

A nivel de sistema, los cuatro elementos principales se comunican entre ellos gracias a dos grupos de interfaces de sistema:

\begin{itemize}
  \item Interfaz de mando.
  
  \item Interfaz radio.
\end{itemize}

En la Figura~\ref{fig:SystArq} se muestra la estructura de más alto nivel de la arquitectura planteada, junto con la relación entre los módulos y los grupos de interfaces. Estos se explicarán en los apartados siguientes.

\begin{figure}[h]
	\centering
	\includegraphics[width=14cm, keepaspectratio]{Imagenes/System_arq.png}
	\caption{Arquitectura de sistema y su bucle de control}
	\label{fig:SystArq}
\end{figure}

La arquitectura del sistema propuesto, se basa en que la estación de tierra atiende los comandos que puedan llegar desde el ordenador de mando, de manera simultánea a las tramas que provengan de los sensores a bordo del dron. El dron, capaz de ubicar de manera local su posición relativa en base a las medidas entregadas por sus sensores, transmite eventualmente por radio su posición hacia la estación de tierra. Ésta calcula el vector de error de posición como la diferencia entre las medidas de posición indicadas por los sensores de posición, y las órdenes recibidas desde el ordenador de mando. En base al vector de error, la estación de tierra computa las correcciones y se las envía por radio al dron en forma de órdenes de movimiento. El dron entonces, obedece dichas órdenes, a continuación vuelve a medir su posición y envía la información de nuevo a la estación de tierra, cerrando así el bucle de control principal del sistema.\\
A continuación se describen los dos sistemas diseñados, junto con el ordenador de mando. Estos componen el sistema completo de este trabajo, con la arquitectura mostrada el la Figura~\ref{fig:SystArq}.

\section{Estación de tierra}
\label{sec:Estación de tierra}

Es el módulo encargado de ejecutar los algoritmos de control y producir las respuestas necesarias para estabilizar y controlar el dron. Para ello procesa los comandos enviados desde el ordenador de mando y las señales medidas por los sensores a bordo. Dicha información se traslada entre sus módulos a través de los interfaces mostrados en la Figura~\ref{fig:GS_arq}. El resultado de su proceso es enviado de vuelta hacia el dron a través las órdenes de movimiento del interfaz radio.

\begin{figure}[h]
	\centering
	\includegraphics[width=16cm, keepaspectratio]{Imagenes/Ground_Station_arq.png}
	\caption{Arquitectura e interfaces de la estación de tierra}
	\label{fig:GS_arq}
\end{figure}

Cada módulo realiza su tarea en base a la información previa que pueda contener, junto con la que se transfiere entre él y los módulos con los que tenga comunicación, dentro de la Figura~\ref{fig:GS_arq}.

\subsection{Descripción}
\label{subsec:GS_Desc}

El sistema propuesto se compone de varias tarjetas mostradas en la Figura~\ref{fig:GS_desc}. Cada tarjeta o tarjetas, forman un módulo de la arquitectura de la estación de tierra. Cada uno realiza una función concreta y necesaria para cubrir algún sub-objetivo, permitir a las demás cumplir con el suyo, o facilitar las tareas de depuración.

\begin{figure}[h]
	\centering
	\includegraphics[width=16cm, keepaspectratio]{Imagenes/Ground_Station_Mod.jpg}
	\caption{Montaje de la estación de tierra}
	\label{fig:GS_desc}
\end{figure}

A continuación se nombran los distintos módulos que componen la estación de tierra, enumerados en la Figura~\ref{fig:GS_desc}:

\begin{itemize}
  \item Módulo 1: Hub USB.
  
  \item Módulo 2: Módulo de procesado y comunicaciones con ordenador de mando.
  
  \item Módulo 3: Módulo de downlink.
  
  \item Módulo 4: Módulo de uplink.
  
  \item Módulo 5: Módulo de depuración.
\end{itemize}

\subsection{Objetivo}
\label{subsec:GS_Obj}

La estación de tierra tiene por objetivo conseguir que el dron obedezca las instrucciones de posición que se envían desde el ordenador de mando. Para ello se diseñarán una serie de funciones, descritas a continuación, que la estación de tierra ejecutará a través de los módulos disponibles. Toda información que se mueva dentro de la estación de tierra, quedará descrita más adelante en los interfaces. Mientras que la información transmitida entre los módulos de la estación de tierra y el exterior (dron, sensores a bordo y ordenador de mando), queda definida en los interfaces del sistema.

\subsection{Funciones}
\label{subsec:GS_Func}

\begin{itemize}
  \item Recepción de tramas enviadas desde el dron por el interfaz de downlink. Función ejecutada por el módulo 3. Deberá demodular y decodificar la información de los sensores de a bordo del dron, transmitida por radio. Tras esto generará un paquete con la información recibida hacia el procesador principal, a través del interfaz UART\_Sensors.
  
  \item Recepción de comandos desde el ordenador de mando. Función ejecutada por el módulo 2. El módulo 2 incluye el driver de USB, FT232HL, el cual deberá recibir los comandos de posición por USB y realizar la conversión a protocolo UART para hacérselos llegar a la FPGA del módulo 2.
  
  \item Procesado de control y dirección del dron. Función ejecutada por el módulo 2. Para la correcta estabilización y control de la posición del dron, el módulo 2 dispone de una FPGA ICE40UP5K. Esta ejecutará el firmware configurado en su lógica interna para cubrir la función de control y estabilización. Dicho firmware ejecutará, entre otras cosas, los bucles de control definidos en el siguiente capítulo, algoritmos de control. 
  
  \item Enlace radio con el dron. Como inicio de las comunicaciones entre la estación de tierra y el dron, el módulo 4 se encarga, tras el arranque, de enlazarse con la electrónica del dron.
  
  \item Transmisión de comandos de movimiento de vuelta al dron. Tras realizar el enlace, el módulo 4 se encarga de transmitir periódicamente las órdenes de movimiento que haya recibido por el interfaz PPM\_Frames.
\end{itemize}


\subsection{Interfaces}
\label{subsec:GS_Int}

\subsubsection{USB}
\label{subsubsec:GS_USB}

Se compone de tres flujos de información distintos, programación, depuración y comandos. A través de  este interfaz se transmiten los comandos entre el ordenador de mando y la estación de tierra, interfaz definido en la sección Interfaz de mando. También abarca la programación de los 3 dispositivos reprogramables del sistema, módulos 2, 3 y 4 y las medidas tomadas por el módulo de depuración.

\subsubsection{SPI}
\label{subsubsec:GS_SPI}

La estación de tierra hace uso de dos puertos SPI para leer cada una de las dos radios disponibles. Se trata de las radios de los módulos 3 y 4, downlink y uplink respectivamente. Ambos hacen uso de una radio modelo NRF24L01, cuyo interfaz de escritura y lectura de registros es un puerto serie SPI. Para esta tarea se hace uso de la librería NRF24L01, distribuida de manera abierta en Github y en la herramienta de instalación de librerías del IDE de Arduino. Por el puerto SPI del downlink, viajan los datos de las medidas de los sensores, leídas a bordo del dron. Por el puerto SPI del uplink, viajan las órdenes de movimiento generadas en el módulo 2, que deberán alcanzar al dron.

\subsubsection{UART \& UART\_Sensors}
\label{subsubsec:GS_UART}

En el sistema se utilizan comunicaciones asíncronas en dos ubicaciones distintas, y para portar distinta información. En primer lugar, se utiliza para recibir los comandos desde el ordenador de mando a través del interfaz UART de la figura 25. El protocolo USB 2.0 es convertido a UART por el driver FT232HL del módulo 2. Una vez convertido, es recibido por la FPGA del mismo módulo, la cual se sincroniza con las tramas recibidas con las características y formato de tramas comentados en el apartado Interfaz de mando.\\
La segunda ubicación donde se hace uso de este protocolo es en la recepción de las medidas de los sensores de a bordo, a través del interfaz UART\_Sensors. Esta interfaz llega desde el módulo de downlink, el cual se encarga de comunicar las medidas de posición a la FPGA del módulo 2, directamente a través de una UART sin paridad ni control de flujo, con 10 bits por byte y una tasa de transferencia de 500Kbps.

\subsubsection{PPM\_Frames}
\label{subsubsec:GS_PPM}

Esta interfaz porta la información de las órdenes de movimiento que deben llegar al dron a través de una comunicación con un solo hilo, desde el módulo 2, hacia el módulo 4. Para ello hace uso de una modulación PPM como la comentada en la introducción. Las órdenes de movimiento han sido calculadas por la FPGA del módulo 2, y se entraman según se especifica en los formatos de trama de la sección del uplink, dentro del interfaz radio de los interfaces del sistema.

\subsection{Módulos}
\label{subsec:GS_Mod}

A continuación se describen los módulos que componen la estación de tierra, mencionados anteriormente y mostrados en la Figura~\ref{fig:GS_desc}.

\subsubsection{Módulo 1: Hub USB}
\label{subsubsec:GS_Mod1}

Centraliza las comunicaciones USB, permitiendo tener un único puerto ocupado en ordenador de mando, y poder acceder desde él a la programación individual de los 3 módulos reprogramables, junto a las sondas de depuración, y alimentar simultáneamente todos los sistemas. También permite el apagado individual, muy útil para restablecer la comunicación con el dron reiniciando el módulo de uplink, sin eliminar la configuración en RAM de los módulos 2 y 3.

\subsubsection{Módulo 2: Procesado y comunicaciones con ordenador}
\label{subsubsec:GS_Mod2}

Se trata del procesador principal del sistema, junto a un regulador de tensión, accesos a varios pines de propósito general y un driver de USB. Como procesador principal se hace uso de una FPGA ICE40UP5K de Lattice en su encapsulado QFN de 48 pines conectada a través de una UART al driver de USB, para el cual se hace uso de un FT232HL, capaz de convertir el protocolo USB a distintos estándares de comunicación. Concretamente el canal A convierte de USB a SPI, para la reprogramación de las memorias RAM interna de la FPGA y la memoria FLASH externa de la tarjeta de desarrollo. Y el canal B convierte de USB a UART, para comunicar las instrucciones de mando desde el ordenador hasta la FPGA.\\
La FPGA de este módulo es la encargada de recibir los comandos desde el ordenador de mando a través de interfaz UART, las medidas de los sensores de a bordo del dron a través del primer interfaz SPI y entrega las órdenes de movimiento por el segundo. Para ello, ejecuta los bucles de control descritos más adelante en el apartado sobre los algoritmos de control de la FPGA. Dichos bucles se nutren de la información recibida por UART originaria del módulo 1 y SPI desde el módulo 3. El resultado de su ejecución es enviado por SPI hacia el módulo 4.

\subsubsection{Módulo 3: Downlink}
\label{subsubsec:GS_Mod3}

Se compone de una radio NRF24L01 conectada por puerto SPI a un procesador de Atmel integrado en una tarjeta Arduino Uno. La radio se alimenta desde la tarjeta del procesador, el cual se alimenta a su vez por USB. También se tiene acceso por USB a la reprogramación del procesador y a su salida de puerto serie para depuración.\\
Este módulo se encarga de recibir las medidas de posición desde los sensores a bordo del dron. Configura la radio como receptora y se mantiene atento por pollin, a la espera de recibir nuevas medidas desde el dron. Cuando las recibe, las entrama con un formato de trama idéntico al descrito en el apartado del downlink, con el añadido al principio de dos bytes de valor 255 y 90, como bytes de sincronía. Técnica de sincronía idéntica a la descrita en el interfaz de mando. De esta manera, aunque se falle la recepción de un byte, el receptor tiene un método para volver a sincronizarse con las siguientes tramas. Además el módulo de downlink incluye un CRC de 8 bits en su mecanismo de comunicación radio y sistema de retransmisiones, lo que dificulta la llegada de bytes erróneos a este nivel (Si puede ocurrir que ante la llegada de múltiples bytes erróneos a la radio, uno o varios queden sin entregar al procesador, tras el vencimiento de los reintentos).\\
Una vez entramadas dichas medidas, las reenvía hacia el módulo 2 a través de la UART especificada en el interfaz UART \& UART\_Sensors.

\subsubsection{Módulo 4: Uplink}
\label{subsubsec:GS_Mod4}

Este módulo se encarga de gestionar el interfaz PPM descrito anteriormente. Se trata de un procesador de Atmel integrado en una tarjeta Arduino Nano, junto con otra radio NRF24L01. La tarjeta Arduino Nano, incluye también regulador de tensión e interfaz USB para cubrir las mismas tareas que en el módulo 3, alimentación propia y de la radio, depuración y programación. El procesador programa la radio como transmisor y lo enlaza con la electrónica del dron. Tras el enlace, comienza a transmitir hacia el dron las órdenes de movimiento demoduladas de la trama PPM recibida periódicamente desde la FPGA del módulo 2.

\subsubsection{Módulo 5: Depuración}
\label{subsubsec:GS_Mod5}

Se trata de un sistema de adquisición digital diseñado por Saleae, para ser usado como analizador lógico. Dispone de una conexión de masa como referencia y ocho canales. Estos se conectan de tal manera que se tiene acceso a la información de los interfaces UART (Órdenes de movimiento recibidas desde el ordenador), UART\_Sensors (Medidas de posición recibidas desde la electrónica de sensorización del dron) y PPM\_Frames (tramas PPM resultado de procesar lo recibido por los dos interfaces previos). De esta manera, se puede depurar el sistema completo una vez en funcionamiento. Ya que el sistema de adquisición de Saleae permite capturas predefinidas en tiempo, se configuran adquisiciones de 5 o 10 segundos y se asocia el disparo de inicio de dicha captura a la recepción de una nueva trama de órdenes de mando. De esta manera se realizan capturas de todos los eventos que se producen por ejemplo desde la recepción de la trama de despegue, hasta el aterrizaje. Esto ha hecho posible gran parte de la depuración de errores y fallos en la estabilidad del sistema o en su ejecución.

\section{Sistema embarcado}
\label{sec:Sistema embarcado}

Para el control del vuelo del dron, es necesario nutrir a la estación de tierra de información sobre el dron. Este sistema se encarga de obtener dicha información y enviársela a la estación de tierra. Para ello dispone de distintos sensores capaces de permitirle ubicar de manera relativa el dron, una radio para comunicar la información, y un procesador para realizar las lecturas de sensores, procesarlas y generar la trama a enviar. Estos módulos y sus interfaces se muestran en la Figura~\ref{fig:OB_arq} y se describen a continuación.

\begin{figure}[h]
	\centering
	\includegraphics[width=14cm, keepaspectratio]{Imagenes/Drone_arq.png}
	\caption{Arquitectura e interfaces del sistema sensor de posición ubicado en el dron}
	\label{fig:OB_arq}
\end{figure}


\subsection{Descripcion}
\label{subsec:OB_Desc}

En la Figura~\ref{fig:OB_desc} se muestran los módulos que componen el montaje de los sensores embarcados.

\begin{figure}[h]
	\centering
	\includegraphics[width=14cm, keepaspectratio]{Imagenes/OnBoard_System_Mod.jpg}
	\caption{Sistema de sensores embarcado}
	\label{fig:OB_desc}
\end{figure}

Este montaje incluye módulos adicionales a los sensores para hacer posible su lectura y comunicación a tierra:

\begin{itemize}
  \item Módulo 1: Procesador Atmel.
  
  \item Módulo 2: Tarjeta de sensores.
  
  \item Módulo 3: Transmisor de downlink.
\end{itemize}

Estos módulos se alimentan desde un pack de batería de 3.6V de Litio, independiente de la electrónica de control del dron. Esto es debido a que a pesar del peso adicional que supone una batería separada, los drivers de motores del dron exigen picos de corriente considerables a las baterías. Estas, que no siempre tienen capacidad de descarga suficiente debido al diseño del dron, caen en tensión. Estas caídas, en caso de alimentar todo el sistema de las mismas baterías, llegan a producir apagados eventuales en la electrónica de los sensores, lo que dificulta el control, volviendo el sistema inestable en la mayor parte de los casos.


\subsection{Objetivo}
\label{subsec:OB_Obj}

Los sensores embarcados tienen el objetivo de proveer a la estación de tierra, con información sobre la posición del dron en cada momento. Para ello cada módulo cubrirá con unas funciones concretas definidas a continuación y se comunicará la información generada a través de los interfaces de la Figura~\ref{fig:OB_arq}, explicados más adelante.


\subsection{Funciones}
\label{subsec:OB_Func}

\begin{itemize}
  \item Medida de distancia al suelo. Función del módulo 2.
  
  \item Medida de velocidad de desplazamiento horizontal. Función del módulo 2.
  
  \item Procesado de las medidas hasta conseguir posición relativa del dron y entramado para transmisión. Función del módulo 1.
  
  \item Transmisión de paquetes con información de posición del dron hacia la estación de tierra. Función del módulo 3.
\end{itemize}


\subsection{Módulos}
\label{subsec:OB_Mod}

\subsubsection{Módulo 1: Procesador}
\label{subsubsec:OB_Mod1}

Este módulo se encarga de inicializar los dos sensores, altura y desplazamiento y realizar lecturas de sus medidas por los interfaces I2C\_Alt y SPI\_XY respectivamente. Una vez tomadas las medidas, se realizan ciertos procesos sobre los datos. El sensor de altura por tiempo de vuelo (ToF) \cite{sensor_tof} sufre errores por debajo de los 3cm de distancia de medida, por tanto este módulo se encarga de filtrar dichos valores erróneos, entregando una medida ficticia de 3cm para toda altura igual o inferior. Esto hará que en ocasiones el dron, ya aterrizado, siga indicando una altura de 3cm. Esto no supone un problema ya que llegado el momento del aterrizaje, la altura ficticia de 3cm medidos, ayuda a descargar el bucle integral, apagando los motores por completo. También realiza las lecturas del sensor de velocidad de desplazamiento horizontal (Flow). El procesador se encarga de convertir estas, en medidas de posición relativas. Para ello integra en el tiempo las medidas de velocidad de desplazamiento, leídas del interfaz SPI\_XY. Ya que el sensor de flujo no mide correctamente para alturas inferiores a 4cm, se aprovecha la lógica de filtrado, para no modificar las medidas de posición en este rango de alturas.\\
Una vez filtradas e integradas, entrama dichas medidas y las reenvía hacia el módulo 3 a través del interfaz SPI\_Radio.

\subsubsection{Módulo 2: Sensores}
\label{subsubsec:OB_Mod2}

Este módulo se compone de una sola tarjeta que integra dos sensores. Juntos ofrecen lo necesario para llegar a conocer la ubicación relativa aproximada del dron. También incluye electrónica auxiliar y conexiones.

\begin{itemize}
  \item ToF: Se trata del sensor VL53L0x, el cual mide la distancia entre su encapsulado y un objeto enfrentado a él, a través de la medida del tiempo de vuelo de una señal laser. Se accede desde el módulo 1, a través del interfaz I2C\_Alt, un puerto serie I2C. Tiene un rango de trabajo de entra 3cm y 2m. Este sensor se apunta hacia el suelo, desde su soporte en el dron, con la intención de medir la distancia al suelo desde el punto medio del dron. De esta manera una vez aterrizado, la distancia mínima de medida, es superior a 3cm, lo cual minimiza la necesidad de filtrado en el procesador (esta última se mantiene igualmente, ya que los apoyos del dron son flexibles, y el sensor tiene tolerancias de medida). Este sensor tiene un retardo de medida de hasta 30ms, el cual dificultará en cierta medida la estabilidad del bucle de control de altura ejecutado en la FPGA.
  
  \item Flow: Como sensor de desplazamiento se hace uso del PMW3901 \cite{motion_module}. Este sensor de movimiento, tiene una óptica diseñada para enfocar a distancias superiores a 8cm. Aunque funciona bien hasta los 4cm si se dispone de buena iluminación. Sus medidas son filtradas como se indica en el proceso del módulo 1. Entrega medida de velocidad de desplazamiento en dos ejes, para el plano captado por su óptica. El montaje apunta el sensor hacia el suelo, desde el mismo soporte que para el sensor de tiempo de vuelo. De esta manera se conocerá la velocidad de desplazamiento horizontal del dron respecto del suelo. Es el módulo 1 el encargado de convertir estas velocidades de desplazamiento en posición relativa. El sensor tiene un puerto de comunicaciones SPI para inicialización y lectura, sus medidas son entregadas al módulo 1 a través del interfaz SPI\_XY.
\end{itemize}

\subsubsection{Módulo 3: Transmisor de downlink}
\label{subsubsec:OB_Mod3}

Se hace uso de una radio NRF24L01 conectada por puerto SPI al módulo 1, a través del interfaz SPI\_Radio. Este módulo transmite las medidas de posición de los sensores del módulo 2, ya procesados y entramados por el módulo 1, hacia la estación de tierra. Se configura la radio como transmisora, con una configuración en los parámetros radio, homóloga a la del módulo de downlink en la estación de tierra. Entonces se transmite una trama, justo después de realizar cada medida de ambos sensores, tiempo de vuelo y flujo. Las tramas son idénticas a las descritas en el apartado del downlink, con el mismo añadido al principio de dos bytes de valor 255 y 90. Esto lo hace compatible con la configuración del módulo de downlink de la estación de tierra. Incluye los mismos mecanismos de retransmisión y comprobación de redundancia cíclica que la radio de la estación de tierra.

\subsection{Interfaces externos}
\label{subsec:OB_IE}

\subsubsection{Position Sensors Measures}
\label{subsubsec:OB_IE_PSM}

Como se muestra en la arquitectura de la Figura~\ref{fig:OB_arq}, enlaza por radio la electrónica de sensores y la estación de tierra. Porta las medidas de posición tomadas por los sensores del módulo 2 y procesadas por el módulo 1. Sus características y tramas están descritas en el apartado del downlink.

\subsubsection{USB}
\label{subsubsec:OB_IE_USB}

Se trata de una comunicación con el ordenador de programación, exclusivo para reprogramación del procesador de Atmel, o extracción de medidas por puerto serie para comprobaciones y depuración.


\subsection{Interfaces internos}
\label{subsec:OB_II}

\subsubsection{I2C\_Alt}
\label{subsubsec:OB_II_I2C}

Comunica por puerto serie I2C, el sensor de medida de altura, VL53L0x del módulo 2, con el procesador del módulo 1. Porta las medidas de distancia entre la zona media del dron y el suelo bajo él, consideradas como la altura del dron.

\subsubsection{SPI\_XY}
\label{subsubsec:OB_II_SPIXY}

Comunica por puerto serie SPI, el sensor de medida de velocidad de desplazamiento, PMW3901, del módulo 2 con el procesador del módulo 1. Porta las medidas velocidad de desplazamiento sobre el plano horizontal en ambos ejes. En este punto, no existe una referencia concreta, ya que se trata de una medida de la velocidad de desplazamiento instantánea.

\subsubsection{SPI\_Radio}
\label{subsubsec:OB_II_SPIRadio}

Puerto serie SPI utilizado para la configuración inicial de la radio NRF24L01, y para la indicación de tramas a enviar. La configuración inicial se parametriza de manera idéntica a la indicada para el downlink, en este caso como radio de transmisión. El formato de tramas coincide de igual manera con el del downlink por compatibilidad. Porta las medidas, ya procesadas por el módulo 1, de los interfaces I2C\_Alt y SPI\_XY.



\section{Ordenador de mando}
\label{sec:Ordenador de mando}

Se trata del ordenador ubicado en el módulo de tierra de la Figura~\ref{fig:SystArq}. Dicho hardware se encarga de ejecutar el código python que dirigirá el vuelo del dron.

\subsection{Objetivo}
\label{subsec:OM_Obj}

El objetivo de este módulo será permitir el control del dron desde PC, ofreciendo la menor cantidad de limitaciones posibles en cuanto a su manejo y configuración. Para ello incluirá la transmisión de tramas que contengan información para el control de los cuatro grados de libertad del dron y los parámetros de sus bucles de control.

\subsection{Funciones}
\label{subsec:OM_Func}


\begin{itemize}
  \item Para alcanzar su objetivo, este módulo ofrecerá la ejecución de instrucciones en python.
  
  \item El resultado de dichas instrucciones deberá ser comunicado hacia la estación de tierra a través de un puerto de comunicaciones serie USB.
\end{itemize}


\subsection{Interfaces}
\label{subsec:OM_Int}

Este módulo dispone de un único interfaz de comunicaciones funcional con el resto del sistema. Se trata del interfaz de comando de la Figura~\ref{fig:SystArq}, el cual contiene las instrucciones de control para dirigir el vuelo del dron.\\
También dispone de un interfaz dedicado en exclusiva a la depuración del sistema mostrado en la Figura~\ref{fig:GS_arq}, el cual no interviene durante la operación normal del sistema. Este porta información desde el analizador lógico, hacia el software de análisis de señales digitales \textit{Logic}.\\


A continuación se detallan los interfaces que conectan los cuatro módulos de nivel superior que toman partido en la arquitectura del sistema de la Figura~\ref{fig:SystArq}; estación de tierra, dron, sensores de a bordo y ordenador de mando. Cabe destacar que no existen interfaces que comuniquen de manera directa el dron, con la electrónica de sensores de a bordo. Esto es debido a que se prefirió aislar dicha electrónica de la del dron por problemas en la alimentación de la electrónica propia del dron y no existe la necesidad específica de comunicar dichos módulos directamente entre ellos (quedan indiréctamente comunicados entre sí a través de la información enviada a tierra, procesada y recibida de vuelta en el dron). Dicho interfaz en cambio si podría darse para arquitecturas de sistema diferentes, como por ejemplo aquellas basadas en la premisa comentada en el apartado \ref{subsec:Mejoras en la arquitectura del sistema}


\section{Interfaz de mando}
\label{sec:Interfaz de mando}

Se encarga de comunicar únicamente el ordenador de mando con la estación de tierra. Porta información de las instrucciones de posición, que se espera el dron obedezca, y parámetros para los bucles de control. Este interfaz tiene dos objetivos principales: Facilitar la comunicación con la estación de tierra, al mismo tiempo que proveer al sistema de una alta capacidad de reconfiguración para disminuir el tiempo entre pruebas. Por este motivo se incluyen los parámetros de los bucles de control como parte de los datos. Esto facilita realizar múltiples ensayos de vuelo consecutivos, con mucha diferencia en el comportamiento de cada uno de ellos.

\subsection{Características}
\label{subsec:Características}

Se trata de una comunicación unidireccional con origen en el ordenador de mando y destino en la estación de tierra. La comunicación se realiza por puerto serie, y se basa en el uso de los estándares USB 2.0 y UART y RS232. Para la conversión del estándar eléctrico desde USB a RS232, se hace uso de un driver de USB de FTDI Chip. El cual también convierte del protocolo de comunicaciones USB a UART. Concretamente el canal B del integrado FT232HL. Dicho driver se encuentra integrado en la placa de desarrollo de la FPGA de Lattice. El canal A se reserva para otras tareas comentadas más adelante en la descripción de los interfaces de la propia estación de tierra. El puerto de comunicaciones se configura en tiempo de ejecución por la herramienta software ejecutada en el ordenador de mando. En ella se indica el número del puerto, el cual depende de la asignación que realice el ordenador en uso y la velocidad de transferencia, la cual se fija en 500Kbps. Esta velocidad irá acorde con la tasa de transferencia del mismo interfaz, del lado de la FPGA, explicado en más adelante. Las tramas se envían desde el ordenador de mando a través del USB con la información adecuada para encapsular cada byte en el formato de comunicaciones propio de una UART. De esta conversión también se encarga el módulo FT232HL a través de la información provista en tiempo de ejecución. Una vez abierto el puerto a la velocidad indicada anteriormente, se envía cada byte sin control de flujo, ni paridad. Se hace uso de diez bits por byte. Bit de inicio, 8 bits de datos y bit de parada.

\subsection{Formato de tramas}
\label{subsec:Formato de tramas}

Se hace uso de un formato de tramas fijas. La longitud es conocida y siempre la misma, 16 bytes. Y la posición de cada valor tampoco varía durante toda la ejecución, lo que facilita las tareas de decodificación y sincronía. A lo largo del trabajo, se han ido añadiendo o modificando campos de la información transmitida por este interfaz, según las necesidades puntuales de pruebas o mejoras a lo largo de la evolución por los distintos objetivos secundarios, hasta alcanzar el objetivo principal.
Cada trama es enviada en el instante de ejecución de cada instrucción en el ordenador de mando. Cada instrucción dispone también de un lapso de tiempo indicado al ejecutarla. De esta manera cada instrucción esta activa el tiempo indicado, hasta que se produzca la ejecución de la siguiente instrucción, o se termine el programa.
En su versión final, las tramas componen sus 16 bytes con la construcción fija mostrada en las Figuras~\ref{fig:tramam1} y \ref{fig:tramam2}: 

\begin{figure}[h]
	\centering
	\includegraphics[width=14cm, keepaspectratio]{Imagenes/Tramas_de_mando_1.png}
	\caption{Formato de trama de mando, primera mitad de la trama}
	\label{fig:tramam1}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[width=14cm, keepaspectratio]{Imagenes/Tramas_de_mando_2.png}
	\caption{Formato de trama de mando, segunda mitad de la trama}
	\label{fig:tramam2}
\end{figure}

\begin{itemize}
  \item Los dos primeros se usan de etapa de sincronía. Campos Stx1 y Stx2. Tienen los valores fijos 255 y 90 en base decimal. Siempre son transmitidos de esta manera. Así, la etapa receptora espera por una secuencia de dos bytes consecutivos con valores 255 y 90 para sincronizar con la trama entrante. Tras esto, el receptor comenzará a decodificar los valores de los siguientes 14 bytes con el orden indicado en la trama. Asumiendo que no se produzca un error de comunicaciones, el equipo receptor asociará cada valor a su campo adecuadamente. 
  
  \item Cmd\_ALT: Comando de vertical, o altura. Representa el valor de la consigna de posición de altura deseada para el dron. Este valor será decodificado por la estación de tierra y enviado al bucle de control de altura como su consigna.
  
  \item Cmd\_L/R: Comando de desplazamiento horizontal lateral. Representa el valor de la consigna de posición lateral deseada para el dron. Este valor será decodificado por la estación de tierra y enviado al bucle de control de desplazamiento lateral, como su valor de consigna. Se trata del eje de libertad asociado al alabeo.
  
  \item  Cmd\_F/B: Comando de desplazamiento horizontal frontal. Representa el valor de la consigna de posición frontal deseada para el dron. Este valor será decodificado por la estación de tierra y enviado al bucle de control de desplazamiento frontal, como su valor de consigna. Se trata del eje de libertad asociado al cabeceo.
  
  \item Cmd\_T\_CW: Comando de giro en sentido horario. Representa el valor deseado de la velocidad de giro del dron, sobre sí mismo. Este valor será decodificado por la estación de tierra y enviado directamente al constructor de tramas, ya que este grado de libertad no se controla con un bucle cerrado de alto nivel. Se le deja su control exclusivamente a la electrónica propia del dron y su giróscopo interno. Se trata del eje de libertad asociado a la guiñada.
  
  \item PID\_Alt\_Kp: Parámetro de la constante proporcional de altura. Representa el valor deseado para la constante proporcional del bucle de control PID de altura. La diferencia  entre el valor de consigna de altura, Cmd\_ALT, y valor de altura medido por los sensores de a bordo, genera el valor de error de altura, componente del vector de error. Esta componente del error se multiplicará por el valor recibido en este campo para conseguir así la componente ``P'' del bucle de control de altura.
  
  \item  PID\_XY\_Kp: Parámetro de la constante proporcional de los ejes horizontales. Representa el valor deseado para las constantes proporcionales de ambos bucles de control PID de posición horizontal. El control de posición frontal y el control de posición lateral. Ya que el dron es simétrico respecto de sus ejes de desplazamiento horizontal, se aplica la misma tensión a ambos bucles de control. La diferencia  entre los valores de las consignas Cmd\_L/R y Cmd\_F/B y sus medidas por los sensores de posición de a bordo, generan los errores de posición horizontales, componentes del vector de error de posición. Estos errores se multiplicarán por el valor recibido en este campo, para conseguir así las componentes ``P'' de los bucles de control de los ejes horizontales: Frontal y latera.
  
  \item RSV: Los bytes de las posiciones 9, 15 y 16 están reservados para posibles usos futuros. Tienen valores constantes a cero.
  
  \item T\_CW\_Trimm: Parámetro de corrección de giro del dron sobre sí mismo. Representa el valor del offset a añadir al valor del comando ``Cmd\_T\_CW'' a enviar hacia el dron. El objetivo de este parámetro es corregir de manera constante el valor de la velocidad de giro sobré si mismo enviado hacia el dron. Ya que este valor se encuentra controlado por un bucle abierto en la electrónica de la estación de tierra, si la electrónica propia del dron, tiene un error constante de giro que no pueda corregir, se aplicará la corrección necesaria a través del valor de este parámetro.
  
  \item  PID\_Alt\_Ki: Parámetro de la constante integral de altura. Representa el valor deseado para la constante integral del bucle de control PID de altura. El valor del error de altura comentado anteriormente, se integrará y multiplicará por el valor recibido en este campo de la trama. De esta manera se consigue la componente ``I'' del  bucle de control de altura.
  
  \item PID\_Alt\_Kd: Parámetro de la constante derivativa de altura. Representa el valor deseado para la constante derivativa del bucle de control PID de altura. El valor del error de altura comentado anteriormente, se derivará y multiplicará por el valor recibido en este campo de la trama. De esta manera se consigue la componente ``D'' del  bucle de control de altura. Este campo junto con los valores de los campos de las posiciones 7 y 11, completan los valores de los parámetros para el bucle de control cerrado PID de la altura.
  
  \item PID\_XY\_Ki: Parámetro de la constante integral de los ejes horizontales. Representa el valor deseado para las constantes integrales de ambos bucles de control PID de posición horizontal. El control de posición frontal y el control de posición lateral. Ya que el dron es simétrico respecto de sus ejes de desplazamiento horizontal, se aplica el mismo peso a las componentes integrales de ambos bucles de control. Los valores de los errores de posición horizontales comentados anteriormente se integrarán y multiplicarán por el valor recibido en este campo, para conseguir así las componentes ``I'' de los bucles de control de los ejes horizontales: Frontal y latera.
  
  \item PID\_XY\_Kd: Parámetro de la constante derivativo de los ejes horizontales. Representa el valor deseado para las constantes derivativas de ambos bucles de control PID de posición horizontal. El control de posición frontal y el control de posición lateral. Ya que el dron es simétrico respecto de sus ejes de desplazamiento horizontal, se aplica el mismo peso a las componentes derivativas de ambos bucles de control. Los valores de los errores de posición horizontales comentados anteriormente se derivarán y multiplicarán por el valor recibido en este campo, para conseguir así las componentes ``D'' de los bucles de control de los ejes horizontales: Frontal y latera. Este campo junto con los valores de los campos de las posiciones 8 y 13, completan los valores de los parámetros para los bucles de control cerrado PID del plano horizontal, Controlador de posición Frontal y Controlador de posición lateral.
\end{itemize}

\section{Interfaz radio}
\label{sec:Interfaz radio}

Se encarga de comunicar la estación de tierra con la electrónica del dron, y los sensores de a bordo, tal como se muestra en la Figura~\ref{fig:SystArq}. Este interfaz porta información fundamental para el desempeño de la tarea de control de posición del dron. Se transmite información tanto de la posición del dron, como de las órdenes de velocidad que este deberá ejecutar. El objetivo de este interfaz es que la estación de tierra conozca la posición relativa del dron, y en base a esto, y a las instrucciones de mando que reciba, trate de dirigir y corregir en caso de error, dicha posición.\\
Se trata de un enlace radio bidireccional entre la estación de tierra y el dron. Dividiremos este enlace en dos partes; la bajada, o downlink, que transmite información desde el dron hacia la estación de tierra. Y la subida, o uplink, que transmite información desde la estación de tierra hacia el dron.\\
Ambos trabajan en la banda libre de 2.4GHz, pero en distintas frecuencias (canales). Así se consigue un enlace bidireccional full-duplex, en base a separación en frecuencia, o FDM. De esta manera ambos pueden estar transmitiendo información simultáneamente, sin colisionar, ni preocuparse de la complejidad y la bajada en la tasa de transferencia propia de un sistema de multiplexación por división en código, CDM.

\subsection{Downlink}
\label{subsec:Downlink}

Se encarga de enlazar por radio los sensores de posición a bordo del dron con la estación de tierra. Porta la información medida por dichos sensores. Esta información se compone de una medida de distancia al suelo, o altura, tomada desde la parte media del dron. Una medida del desplazamiento frontal relativa al punto de despegue. Y una medida del desplazamiento lateral relativa también al punto de despegue.\\
Las tres medidas se miden y transmiten por el interfaz radio en milímetros, considerando como origen de coordenadas, tanto para la altura como para los desplazamientos horizontales, la posición de despegue inicial.

\subsubsection{Características}
\label{subsubsec:Down_Car}

Ocupa el canal 0x66 dentro de la banda libre de 2.4GHz utilizada por el transceptor NRF24L01. Se trata de una transmisión de baja potencia, con un alcance de unos 30 metros, transmitiendo a 1Mbps.

\subsubsection{Formato de trama}
\label{subsubsec:Down_FT}

Se hace uso de un formato de tramas fijas, como para el caso de las tramas de mando. En este caso la longitud de la trama es de seis bytes. Y la posición de cada valor tampoco varía durante toda la ejecución.
Cada trama es enviada en el instante inmediatamente posterior a la ejecución de las tres medidas de posición; altura, desplazamiento frontal y desplazamiento lateral. El formato de las tramas se muestra en la Figura~\ref{fig:down_frame}.

\begin{figure}[h]
	\centering
	\includegraphics[width=14cm, keepaspectratio]{Imagenes/Tramas_de_Downlink.png}
	\caption{Formato de trama de downlink}
	\label{fig:down_frame}
\end{figure}

En estas tramas la sincronía está garantizada como parte del diseño de la transmisión realizada por la radio NRF24L01 y la forma en que esta se comunica con la electrónica de la estación de tierra, que se detallará más adelante. Por tanto los seis bytes de la trama son tres campos útiles de dos bytes cada uno.

\begin{itemize}
  \item H\_Pos\_F/B: Valor de la medida del desplazamiento frontal. Representa los milímetros de desplazamiento frontal desde el origen de coordenadas definido anteriormente. Se almacena en 16 bits consecutivos, y se codifica en complemento a dos.
  
  \item H\_Pos\_L/R: Homólogo al campo ``H\_Pos\_F/B'' con la salvedad de que este representa los milímetros de desplazamiento lateral desde el origen de coordenadas. Codificado también de la misma manera.
  
  \item Alt: Valor de la medida de altura. Representa los milímetros de desplazamiento vertical desde el origen de coordenadas. Se almacena en 16 bits consecutivos, y se codifica en binario plano, ya que no se contemplan alturas negativas para el marco de este TFG.
  
\end{itemize}

Con estas tres medidas, la estación de tierra puede ubicar de manera relativa el dron, generando así el vector de posición necesario para realizar posteriormente las correcciones de posición respecto de las órdenes comandadas.

\subsection{Uplink}
\label{subsec:Uplink}

Se encarga de enlazar por radio la estación de tierra con la electrónica del dron. Comunica las indicaciones de velocidad para cada eje, junto con canales auxiliares cuya función depende de cada dron. En este TFG no se hará uso de dichos canales auxiliares. 

\subsubsection{Características}
\label{subsubsec:Up_Car}

De igual  manera que el interfaz de bajada, hace uso de una radio NRF24L01 en la banda de 2.4GHz. El módulo que gestiona este interfaz, controla la radio NRF24L01. Este módulo está diseñado para recibir los canales a codificar en la trama radio, desde una señal modulada por posición de pulso, PPM. Dicha modulación y sus características se describen más adelante en el apartado de interfaces de la estación de tierra, junto con el módulo que gestiona la radio del uplink. 

\subsubsection{Formato de trama}
\label{subsubsec:Up_FT}

Este interfaz se compone de una transmisión de doce canales, de los cuales se hará uso exclusivamente de los cuatro primeros. Los ocho canales restantes portan comandos auxiliares, como la velocidad de reacción deseada para el dron, la cual se mantiene en su valor por defecto, y dependiendo del modelo exacto del dron utilizado, a veces se utilizan para disparar fotografías o video de la cámara instalada. El subsistema radio se encarga de transmitir la información contenida en la trama de la Figura~\ref{fig:up_frame} por radio hacia la electrónica del dron.

\begin{figure}[h]
	\centering
	\includegraphics[width=14cm, keepaspectratio]{Imagenes/Tramas_de_Uplink.png}
	\caption{Formato de trama de uplink}
	\label{fig:up_frame}
\end{figure}

\begin{itemize}
  \item Cmd\_THR: Valor de velocidad de altura. Ocupa la primera posición en la trama. Representa el impulso deseado para el eje vertical del dron. Un valor de cero no tiene por qué implicar el apagado de los motores, depende de los valores de los siguientes dos canales. 
  
  \item Cmd\_R/L: Valor de velocidad de desplazamiento latera. Representa la velocidad de desplazamiento lateral deseada para el dron. Está asociado al grado de libertad del alabeo.
  
  \item Cmd\_F/B: Valor de velocidad de desplazamiento frontal. Representa la velocidad de desplazamiento frontal deseada para el dron. Está asociado al grado de libertad del cabeceo.
  
  \item Cmd\_T\_CW: Valor de velocidad de giro. Representa la velocidad de giro sobre sí mismo deseada para el dron. Está asociado al grado de libertad de la guiñada. 
  
  \item Aux: Algunos de los ocho canales adicionales tienen valores fijos y otros variables, dependiendo de su funcionalidad y del dron utilizado. Para este trabajo, estos canales se mantendrán con su valor por defecto.
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Módulos Software %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage % empezamos en página impar

\chapter{Módulos Software}
\label{chap:Módulos Software}

El sistema hace uso de 4 procesadores distintos. Tres de ellos ejecutan código C++ para tareas de gestión de puerto serie, inicialización de módulos y comunicación de datos. El cuarto es la FPGA, cuya lógica se define en Verilog 2001 y cubre tareas de procesamiento de señales mediante bucles de control, diseñados en base a bucles cerrados PID y comunicación de las medidas y resultados por puertos serie PPM respectivamente.\\
A continuación se explican los mecanismos ejecutados en cada caso.

\section{Algoritmos de control sobre la FPGA}
\label{sec:Algoritmos de control sobre la FPGA}

La lógica de la FPGA se encarga procesar información procedente de dos fuentes distintas, ordenador de mando y dron.

\begin{itemize}
  \item Por un lado, recibe información desde el ordenador de mando, a través de un puerto serie asíncrono con destino en el módulo, UART PC Frames \& Sync de la Figura~\ref{fig:FPGA_arq}. Las características y el formato de las tramas recibidas por esta vía se describen en el apartado Interfaz de mando. De cada trama se decodifica información para los tres bucles de control PID. La información decodificada por el módulo PC Frame Decoder incluye información de cada PID. Esta es enviada hacia cada controlador según corresponda. A través del flujos de datos Alt Command \& Alt KpKiKd, se envía la información del comando de altura recibido, es decir, la altura deseada para el dron en ese instante, junto con los parámetros proporcional, integral y derivativo del bucle de control de altura. La misma información pero particularizada a cada uno de los dos ejes horizontales es portada por los interfaces Forward Command \& XY KpKiKd y Side Command \& XY KpKiKd. Con la particularidad de que estos dos comparten parámetros PID. De esta manera puede actualizarse casi por completo el comportamiento de los bucles de control, según lo que se reciba en cada trama de mando enviada. Adicionalmente la trama incluye información sobre la orden de giro a entregar directamente al módulo de escalado. Este parámetro, como se ha comentado anteriormente, no pasa por un PID ejecutado en la FPGA, sino que se transfiere directamente hacia el dron, por no disponer de un elemento de medida a bordo. Dicho elemento de medida no se introdujo ya que los errores de giro son suficientemente pequeños como para despreciarlos.
  
  \item Por otro lado se recibe información desde los sensores embarcados en el dron en el módulo UART Drone Frames \& Sync, decodificada en este caso por el módulo Drone Frame Decoder. Las medidas tomadas son entregadas a través de los flujos de datos X, Y, Z Measures, a los bucles de control correspondientes. Estos hacen referencia al desplazamiento latera (Bucle Side PID), frontal (Bucle Forw PID) y en altura (Bucle Alt PID), respectivamente. En este punto, los bucles y el módulo de escalado de giro, tienen toda la información necesaria para trabajar.
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[width=14cm, keepaspectratio]{Imagenes/FPGA_Soft_arq.png}
	\caption{Arquitectura del firmware programado sobre la FPGA}
	\label{fig:FPGA_arq}
\end{figure}

Cada bucle de control de cada eje se diseña en base a un controlador PID. Cada uno Tendrá entonces como entrada de comando, el valor recibido desde el decodificador de tramas de PC para su eje concreto. Como entrada de retroalimentación, tendrán la medida del sensor de desplazamiento del eje acorde, recibido desde el decodificador de tramas del dron. Calculando la diferencia entre el comando y la medida del sensor, se tendrá el error a procesar por el PID de dicho eje, de manera independiente de los demás ejes. Los bucles integral y derivativo, realizan su tarea diferencial a la velocidad de cierre del bucle. Esta es de 30.3Hz. Por tanto el tiempo de derivación y el tiempo de integración serán constantes con un valor de 33ms. Por el contrario como se ha comentado anteriormente, los parámetros PID, por los que se multiplican las componentes del error proporcional, el error integrado en el tiempo y el error derivado respecto del tiempo, son variables recibidas en las tramas de mando. Dichas variables suelen modificarse en momento clave de la ejecución de las instrucciones de mando, como despegue, vuelo y aterrizaje, permitiendo cierta flexibilidad a la hora de realizar distintas tareas.

\section{Software en el módulo de Downlink embarcado}
\label{sec:Software en el módulo de Downlink embarcado}

El software planteado a bordo del dron se encarga de inicializar radio y sensores, para posteriormente realizar una medida de cada sensor y transmitirlas por radio. El objetivo es informar a la estación de tierra de las medidas de a bordo Sus requisitos son, consumir la menor cantidad de energía posible, realizar su función rápidamente, entreteniéndose lo menor posible en tareas secundarias, y transmitir las medidas con la menor cantidad de latencia posible. Para cubrir estos objetivos, el software se ha diseñado de manera sencilla. Se comienza inicializando los sensores y la radio sin modificar sus parámetros durante la ejecución y se prepara una estructura de datos en la que quepa la trama entera a transmitir por radio, en grupos de dos bytes:\\
\begin{verbatim}
struct TxFrame{
  int16_t H_disp_front;	// Frontal displacement counter
  int16_t H_disp_side;  // Side displacement counter
  int16_t altitude;     // Altitude counter
};
\end{verbatim}
Entonces se realiza una medida de cada sensor, se filtran las medidas y el resultado se almacena en la estructura TxFrame. Esta es transmitida por radio a 2 Mbps, y se comienza de nuevo el bucle hasta que se apague la electrónica.

\section{Librería Python}
\label{sec:Librería Python}

El software ejecutado en python en el ordenador de mando es el encargado de enviar las tramas de mando hacia la estación de tierra. Este se encarga de permitir modificar tanto los parámetros de los bucles PID, como sus consignas de posición, además de inicializar el enlace USB con la UART receptora en la FPGA.\\
A través de la ejecución de la función \textit{setPIDValues} dentro del módulo control\_functions.py se cargan los valores de las constantes para los PIDs vertical y horizontales, junto al offset para la corrección del error de giro.

\begin{flushleft}
\textit{def} setPIDValues(alt\_kp, alt\_ki, alt\_kd, xy\_kp, xy\_ki, xy\_kd, OffGiroDI):
\end{flushleft}

\begin{itemize}
  \item Los parámetros: alt\_kp, alt\_ki y alt\_kd, controlan las constantes, proporcional, integral y derivativa respectivamente, del bucle de control PID de altura.
  
  \item Los parámetros: xy\_kp, xy\_ki, xy\_kd, se aplican a las constantes, proporcional, integral y derivativa respectivamente, de ambos bucle de control PID horizontales.
  
  \item El parámetro OffGiroDI, es el encargado de permitir corregir el error, si lo hubiere, en el control del giro sobre sí mismo del dron.
\end{itemize}

Tras al menos una ejecución de esta función, se puede proceder a enviar instrucciones de mando al dron. Estas pueden enviarse de manera directa a través de la instrucción setcontrols:

\begin{flushleft}
\textit{def} setcontrols (ArrAb, DerIzq, DelDet, GiroDI, Duracion):
\end{flushleft}

\begin{itemize}
  \item Los parámetros: ArrAb, DerIzq y DelDet, son las consignas para los bucles de control PID en la FPGA. Estos son enviados a su destino a través de los flujos de datos Alt\_Command, Side\_Command, Forward\_Command de la Figura~\ref{fig:FPGA_arq}, respectivamente.
  
  \item El parámetro GiroDI, es enviado hacia el módulo de escalado de rango, Scaler, de la arquitectura de la Figura~\ref{fig:FPGA_arq}.
  
  \item Duracion, es el parámetro utilizado para especificar el tiempo mínimo de espera para la ejecución de esta instrucción, en segundos. Tras este periodo de tiempo se podrá ejecutar la siguiente instrucción de mando.
\end{itemize}

Adicionalmente al método de control directo, se puede hacer uso de la función settrace.

\begin{flushleft}
\textit{def} settrace (ArrAb, DerIzq, DelDet, GiroDI, Duracion, Steps):
\end{flushleft}

Esta función hace uso de \textit{setcontrols},  para generar puntos intermedios en una trayectoria larga. Los parámetros son los mismos que para \textit{setcontrols}, salvo por el añadido de Steps, que indica el número de puntos intermedios a crear entre el punto actual y el destino indicado. Esta función es útil en casos en los que se quiera recorrer distancias de más de pocos centímetros. Esto es debido a que en caso de por ejemplo, despegue y posterior indicación de vuelo a una distancia considerable del punto de origen, los bucles de control partirían de un error grande, lo que se intenta resolver con un  empuje considerable en la dirección de corrección del error. A pesar del posterior suavizado en la aceleración, de la componente derivativa, este empuje excesivo en ocasiones puede desestabilizar el control de los bucles PID y dificultar la adecuada medida de la ubicación por parte del sensor óptico. Además al inclinar bruscamente el dron, el sensor de altura mide una distancia mayor, debido al nuevo ángulo de incidencia sobre el suelo. Esto se traduce en un avance tortuoso del dron, como avanzando ``a tirones'' hacia su destino. Para evitar esto, \textit{settrace} genera la ristra de avances de menor distancia, evitando el crecimiento excesivo de los errores calculados por los bucles.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Validación experimental %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage % empezamos en página impar
\chapter{Validación experimental}
\label{chap:Validación experimental}

\section{Eachine E010}
\label{sec:Eachine E010}

En principio se hizo uso del dron Eachine E010. Se trata de un pequeño cuadricóptero, ligero y de reacciones nerviosas. Cuenta con 8cm de ancho y 8 cm de largo, conductores en las aspas, para minimizar vórtices, batería de litio y 30 metros de alcance con su radio de 2.4GHz. Sobre él se hicieron pruebas de control en bucle abierto. Se realizaron las tareas de enlace de comunicaciones entre la estación de tierra y el dron y se probaron despegues con aterrizajes y vuelos cortos de ida y vuelta en línea recta.\\
El dron mostró buen control de vuelo en tiempo cortos, por tanto fue válido para pruebas de bucle abierto con algo de pre-énfasis. El dron, presentaba derivas erráticas en uno de sus ejes horizontales, y grandes derivas en el eje vertical, dependientes, entre otras cosas, del nivel de batería. Estas dificultades hicieron de los vuelos largos en bucle abierto, una tarea imposibles. Por tanto se intentó instalar el controlador de vuelo de bucle cerrado en dicho dron. Desgraciadamente el peso de la electrónica disponible era excesivo y hubo que abortar los intentos y buscar una plataforma de mayor potencia. Por este motivo se seleccionó el dron Syma X5C finalmente, frente al pequeño E010.


\section{Syma X5C en Bucle abierto}
\label{sec:Syma X5C en Bucle abierto}

Tras las pruebas con el E010, inicialmente se tuvo que conseguir el mismo control sobre el X5C. Para ellos se modificó el código de enlace con el dron, ejecutado en el módulo de uplink, para conseguir control básico sobre el X5C. Una vez enlazado se hicieron pruebas de control en bucle abierto de igual manera que con el E010. El dron Syma, resulto también difícil de controlar en bucle abierto para vuelos de más de 10 o 15 segundos. A parte de sus desvíos poco previsibles en cada eje, lo cual dificultaba ejecutar correcciones en base a ?trimado?, este dron presentaba una degradación considerablemente notable en la potencia de los motores a medida que se gastaba la batería. Posiblemente debido a la baja calidad de las baterías y de los controladores de los motores, junto a la inexistencia de reguladores de tensión, este problema dificultaba extremadamente su control en altura, haciéndolo casi imposible en bucle abierto. Se procedió por tanto rápidamente a instalarle el sistema de medida de posición. El X5C si era capaz de levantar la electrónica embarcada, pero sus motores quedaban encendidos casi al máximo de su potencia para mantener el vuelo. Esto continuaba dificultando el correcto control en altura, generando oscilaciones de una amplitud imposible de corregir para el PID de altura. En este punto, al menos existía un mínimo de control sobre el dron, con escasa estabilidad. Por tanto se procedió a aligerar la electrónica con cambios menores, y aligerar el dron, con modificaciones mayores. Básicamente se libró al dron de todo aquello estrictamente innecesario para el vuelo. Se acortaron cables, se eliminaron luces de indicación de frente, soporte de cámara, amarre de batería, topes de motores, protecciones de aspas, tornillos, y media estructura de plástico del dron. Algunos elementos retirados se sustituyeron por puntos de soldadura o pegamento, en pro de aligerar todo lo posible. Al retirar media estructura, la resultante pecaba de exceso de flexibilidad y falta de rigidez, lo que eliminó parte de la independencia de ejes, pero permitió a los controladores, ganar bastante en cuanto a estabilización del dron. En este punto el trabajo pendiente se centró en mejorar los parámetros PID de los controladores diseñados para el dron previo al cambio de peso, ya que los anteriores no eran correctos con el nuevo sistema. Además se trabajó rotando dos baterías y controlando rigurosamente su nivel de carga, ya que aunque los bucles de control PID corrigen parte de la disminución de potencia en los motores debido a la descarga de las baterías, llegado un nivel de carga bajo, los parámetros de control mismos, dejaban de ser igual de efectivos, y la velocidad de respuesta también disminuía, lo que al final se traducía en el mismo efecto, parámetros PID inadecuados. Procurando trabajar con baterías en un rango de carga concreto, se minimizo lo suficiente este efecto como para poder mejorar la estabilidad y control sobre el dron.


\section{Pruebas Unitarias}
\label{sec:Pruebas Unitarias}

En este apartado se describen las pruebas realizadas sobre los distintos módulos del sistema, previas a su integración.


\subsection{Pruebas de los módulos de downlink}
\label{subsec:Pruebas en modulos de downlink}

Los softwares ejecutados en los módulos, downlink embarcado y downlink en la estación de tierra, se probaron inicialmente a través de sus interfaces de salida USB.\\
Para el código del módulo de downlink embarcado, se preparó la lectura de los sensores y la transmisión por radio de los datos leídos, simultáneamente al envío por USB de los mismos. de esta manera se pudo verificar visualmente que los sensores medían de manera adecuada a través del USB. En la Figura~\ref{fig:DownDroneCap} se muestra una captura con las medidas extraídas por USB de los sensores de embarcados.

\begin{figure}[h]
	\centering
	\includegraphics[width=14cm, keepaspectratio]{Imagenes/Drone_Sensors_Cap.png}
	\caption{Captura de medidas con sensores de a bordo}
	\label{fig:DownDroneCap}
\end{figure}

Para la comprobación del correcto funcionamiento del módulo donwlink en tierra y su enlace radio con el módulo embarcado, se procedió a encender ambos módulos de downlink y realizar lecturas en el interfaz UART\_Sensors de la estación de tierra (Figura~\ref{fig:SystArq}), tal como se realizó para el módulo de downlink embarcado. Contrastando estas medidas con las de la Figura~\ref{fig:DownDroneCap} se pudo comprobar la correcta medida de los sensores, empaquetado, transmisión y recepción en tierra de dichas medidas.


\subsection{Pruebas del módulo de uplink}
\label{subsec:Pruebas en modulo de uplink}

Este módulo se verificó a través de las pruebas de enlace con los distintos drones utilizados durante el desarrollo del TFG. Estas se realizaron en el punto de partida del proyecto, durante la creación del código que cubre el objetivo~\ref{subsec:Enlace con el drone}. Durante el establecimiento del enlace entre el módulo de uplink y el dron, las luces de indicación de frente del dron cambian su patrón de parpadeo. En caso de un correcto enlace, dichas luces quedan fijas. Esta comprobación visual es suficiente para verificar el enlace, y de paso la correcta construcción y programación del módulo de uplink.


\subsection{Pruebas de módulos software}
\label{subsec:Pruebas de modulos software}

El módulo dos de la estación de tierra (Procesado y comunicaciones en~\ref{subsubsec:GS_Mod2}, mostrado en el apartado~\ref{subsec:GS_Desc}) ejecuta el software principal del sistema, compuesto de múltiples módulos diseñados en Verilog. Los módulos más sencillos se instanciaron tras la codificación, directamente sobre el sistema final. Los módulos restantes, debido a su complejidad o impacto en la seguridad del sistema, se verificaron de manera individual a través de simulaciones lógicas, previa su integración.

\subsubsection{Prueba de módulo decodificador de tramas de mando}
\label{subsubsec:Prueba de modulo decodificador de tramas desde PC}

El test consiste en enviar hacia el decodificador una trama completa para comprobar su correcta decodificación. Los valores incluidos en la trama van de 1 a 14 con valores crecientes. En la Figura~\ref{fig:FrameDecoderCap} se observa la trama enviada en la señal \textit{sink\_data} y su correcta decodificación junto a la señal de datos válidos asertada en el instante de recepción del último byte con valor 0x0E. El test solo captura en sus salidas los ocho primeros bytes ya que el módulo se diseñó originalmente para la recepción de tramas orientadas al control del dron en bucle abierto. Una vez comprobada la correcta decodificación de la trama, su funcionalidad de aumentó durante el desarrollo del trabajo para decodificar tramas completas, incluyendo los valores de los parámetros de los PIDs.

\begin{figure}[h]
	\centering
	\includegraphics[width=17cm, keepaspectratio]{Imagenes/Cap_Mod_frame_decoder_SP13PI1.png}
	\caption{Simulación funcional del módulo decodificador de tramas de mando}
	\label{fig:FrameDecoderCap}
\end{figure}

\subsubsection{Prueba de módulo decodificador de tramas desde drone}
\label{subsubsec:Prueba de modulo decodificador de tramas desde drone}

De manera similar al test ejecutado para el módulo decodificador de tramas desde PC, este módulo se ensayó bajo recepción de una trama completa y posterior comprobación de su decodificación. En este caso, las señales recibidas son valores enteros de dieciséis bits en complemento a dos, separados en grupos de dos bytes. Por tanto el ensayo envía un valor negativo (-2) como desplazamiento frontal, un valor positivo mayor que 255 como desplazamiento lateral (400) y un valor positivo menor que 255 como altura (31). El resultado de la decodificación se muestra en la Figura~\ref{fig:FrameDroneDecoderCap}, de manera síncrona al pulso en la señal \textit{source\_data\_valid} en las tres señales posteriores.

\begin{figure}[h]
	\centering
	\includegraphics[width=17cm, keepaspectratio]{Imagenes/Cap_Mod_frame_dron_decoder_SP18PI1.png}
	\caption{Simulación funcional del módulo decodificador de tramas de sensores}
	\label{fig:FrameDroneDecoderCap}
\end{figure}

\subsubsection{Prueba de módulo conversor de pulsaciones}
\label{subsubsec:Prueba de modulo conversor de pulsaciones}

Este módulo fue ensayado como parte de las pruebas previas al diseño de la arquitectura final para el TFG. Durante la fase de control de bucle abierto se hizo uso de un módulo en la FPGA que recibía la pulsación de ciertas teclas en el PC y las codificaba como parte del proceso de identificación de tecla pulsada. La secuencia enviada en la señal \textit{sink\_data} de la Figura~\ref{fig:KeyPressCap} simula las pulsaciones ``w'', ``a'', ``w'', ``s'', ``d'', caracter desconocido, shift izquierdo, espacio y ``b''. Dichas pulsaciones se codifican con distintos valores de 0 a 6. Ignorando la entrada de una pulsación en un carácter desconocido.

\begin{figure}[h]
	\centering
	\includegraphics[width=17cm, keepaspectratio]{Imagenes/Cap_Mod_KeyPress_SP6PI1.png}
	\caption{Simulación funcional del módulo de conversión de pulsaciones}
	\label{fig:KeyPressCap}
\end{figure}

\subsubsection{Prueba de módulos PID}
\label{subsubsec:Prueba de modulos PID}

Los módulos PID que controlan altura y desplazamientos frontal y lateral hacen uso de una lógica similar, salvando diferencias menores como el truncamiento de valores negativos para el caso del PID de altura y el ajuste de salida a los rangos esperados para la generación de las señales PPM. Los ensayos se realizaron en cuatro escenarios distintos, para comprobar el correcto funcionamiento de las distintas componentes:

\begin{itemize}
  \item TEST\_1: Ensaya la componente proporcional en sentido negativo. El resultado del bucle en negativo se observa en la señal \textit{pid\_prereg} de la Figura~\ref{fig:PIDAltCap}. Dicho valor es capado posteriormente a cero en el registro de salida del módulo PID \textit{source\_pid}.
  
  \item TEST\_2.1: Ensaya la componente integral en sentido positivo. Su crecimiento se observa sobre el registro \textit{error\_i\_acumm} con suma resultante sobre \textit{source\_pid}.
  
  \item TEST\_2.2: Tiene por objetivo ensayar el comportamiento del módulo para el caso de la puesta a cero de los parámetros que rigen el PID. Se desea conservar el valor integral, sin aplicar sobre el módulo correcciones adicionales o puestas a ceros inadecuadas.
  
  \item TEST\_3.1: En este caso de ensayo se pone a prueba la componente derivativa. Para ello se genera un error en sentido negativo y se observa el impacto de la derivada sobre la señal \textit{source\_pid} de la Figura~\ref{fig:PIDAltCap}.
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[width=18cm, keepaspectratio]{Imagenes/Cap_Mod_pid_altitude_SP19PI6.png}
	\caption{Simulación funcional del módulo PID de altura}
	\label{fig:PIDAltCap}
\end{figure}

\subsubsection{Prueba de módulo de comunicaciones UART}
\label{subsubsec:Prueba de modulo de comunicaciones UART}

El objetivo de este ensayo es comprobar que el módulo UART, responde al baud rate programdo y que la decodificación del byte entrante se realiza en el orden adecuado, a efectos de bit más y menos significativos. Se inyecta un cero, seguido de un uno a través de la señal \textit{sdin}, en orden de bit menos significativo primero. El resultado se puede observar en la señal data, síncrona con la señal data\_rdy de la Figura~\ref{fig:UARTCap}, sin errores de trama para ninguno de los dos casos ensayados.

\begin{figure}[h]
	\centering
	\includegraphics[width=18cm, keepaspectratio]{Imagenes/Cap_Mod_uart_rx_SP8PI1.png}
	\caption{Simulación funcional del módulo UART}
	\label{fig:UARTCap}
\end{figure}


\subsubsection{Prueba de módulo de modulación PPM}
\label{subsubsec:Prueba de modulo de modulación PPM}

Este ensayo permite verificar las correctas transiciones entre los estados de cada canal y entre los 12 canales. En la Figura~\ref{fig:PPMCap} se observa el registro \textit{PPM\_STATE}, que almacena el estado encargado de contabilizar el tiempo a cero de cada pulso de bajada. Por otro lado el estado \textit{CHOOSE\_CHANNEL} se encarga de gestionar las transiciones para cada canal.

\begin{figure}[h]
	\centering
	\includegraphics[width=18cm, keepaspectratio]{Imagenes/Cap_Mod_ppm_encoder_SP10PI1.png}
	\caption{Simulación funcional del módulo PPM}
	\label{fig:PPMCap}
\end{figure}

Este ensayo permitió corregir errores en las transiciones entre estados, que producían saltos inadecuados.


\section{Condiciones de los bucles de control}
\label{sec:Condiciones de los bucles de control}

Desde un punto de vista alejado de los parámetros PID de los bucles de control, existen algunos factores importantes que limitan los resultados obtenibles con una arquitectura concreta. Para el caso de este trabajo, la arquitectura elegida permitió usar tarjetas de desarrollo en vez de hardware propietario, ahorrando tiempo de desarrollo y costes. Pero a su vez implicó ciertas limitaciones en el ancho de banda final del sistema y sobre todo en las latencias. Ambos dos tienen relación directa con el resultado de la calidad del control final.

\subsection{Ancho de banda}
\label{subsec:Ancho de banda}

El ancho de banda se vio limitado por las velocidades de ejecución más lentas dentro del sistema, estas son la velocidad de recepción de tramas de la electrónica propia del dron, la cual limita cuantas órdenes puede atender por segundo, y la lectura de los sensores, limitada por la electrónica embarcada y las especificaciones de los propios sensores. Finalmente se estableció una velocidad de lectura de 30.3 hercios, que permitía a los sensores ser leídos adecuadamente, y a la electrónica propia del dron, atender todas las tramas entrantes. Esto limita la brusquedad de las reacciones del dron, en caso de correcciones necesarias, y la suavidad del mismo durante su vuelo.

\subsection{Retardo}
\label{subsec:Retardo}

Aunque el ancho de banda es un parámetro fundamental en el control de un sistema, para el caso de este TFG, la mayor cantidad de problemas durante el desarrollo y pruebas del sistema, fueron originados por falta de estabilidad. Esta se pone en riesgo por múltiples factores, algunos ya comentados, pero principalmente por los retardos en la ejecución de los bucles de control. El tiempo que transcurre desde que se realiza la medida de posición de un eje, hasta que se actúa en consecuencia para corregir el error, es fundamental para estabilizar correctamente el vehículo.\\
En este aspecto, hay varias fuentes de retardo en el sistema, algunas inherentes a algún componente, como los retardos de medida de los sensores, y otras, fruto de la arquitectura escogida. Por ejemplo el hecho de que el proceso de control sea ejecutado en tierra y no a bordo del dron, genera retardos asociados a la transmisión de los valores. Las medidas no son procesadas a bordo sino que se transmiten hacia tierra, donde se procesan para obtener una respuesta, y dicha respuesta se devuelve al dron. Este proceso de transmisión a tierra añade retardos indeseados, pero necesarios para el funcionamiento del sistema.\\
Si tratamos de contabilizar a groso modo los retardos existentes, tenemos:

\begin{itemize}
  \item 30ms del sensor de medida de altura, ToF.
  
  \item Retardo máximo añadido por la sincronía entre la trama PPM  enviada desde la FPGA, y la lectura realizada por la electrónica de uplink, 33ms.
  
  \item Enlaces radio, no más de 120uS sin contar preámbulos.
  
  \item Tres comunicaciones SPI, unos 144us.
  
  \item Dos transmisiones UART de no más de 240uS.
\end{itemize}

A falta de contabilizar de manera más fina los retardos, es sabido que existe un mínimo de 63.5ms de retardo entre medida de la posición y reacción. Esto, sin ser una cifra catastrófica, si es cierto que implica ciertas limitaciones a la hora de conseguir una suavidad de vuelo concreta.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Conclusiones %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage % empezamos en página impar
\chapter{Conclusiones}
\label{chap:Conclusiones}

Para terminar, realizaremos un repaso de los objetivos alcanzados, los métodos y las dificultades encontradas en el proceso. Gracias a ellas se ha sufrido y aprendido durante todo el proyecto. A cada elemento diseñado, se han encontrado formas mejores de hacerlo en un futuro, alternativas con propiedades distintas y opciones a elementos sueltos o la propia arquitectura misma, que podrían dar resultados diferentes y mejores. Finalmente se ha conseguido un resultado satisfactorio con el objetivo principal que se tenía, estabilizar y controlar un dron de bajo coste desde un ordenador. El trabajo podría dividirse en dos grandes bloques, control del dron mediante bucles abiertos y control mediante bucles cerrados.

\begin{itemize}
  \item Control mediante bucles abiertos: Esta fue la primera aproximación a tener un control mínimo de los vehículos desde el ordenador. El resultado fue positivo desde el punto de vista de lo que este tipo de sistemas pueden llegar a ofrecer. Se diseñó software y hardware completamente funcional, permitiendo el enlace con el dron y su obediencia ante las instrucciones dadas desde el pc. Pero las derivas propias de los drones, especialmente notables en drones de bajo coste, dificultaron excesivamente un buen control del mismo mediante esta metodología. Los resultados conseguidos permitían controlar un dron, comandándole instrucciones que este obedecía, pero dicho control era precario, falto de precisión y repetitividad. Para un ejercicio de despegue y parada en vuelo, llegaba un momento en que dichas derivas dirigían el dron contra el suelo, contra una pared, etc. La problemática de este método era difícil de subsanar con la infraestructura disponible, por este motivo se procedió a evolucionar todo el sistema, hardware y software, tanto en tierra como a bordo, dotándolo de una nueva dimensión, conocimiento en el dron de la propia ubicación relativa del dron. Esto supuso poder avanzar al siguiente tipo de control.
  
  \item  Control mediante bucles cerrados: Esta fue la arquitectura definitiva diseñada para el control del dron. Se diseñó electrónica y software para permitir al dron medir su propia ubicación respecto del punto de despegue y transmitirla al sistema en tierra. La estación de tierra recibió añadidos hardware, y una completa actualización de software para recibir, procesar y corregir la ubicación del dron mediante PIDs, enlaces serie y radio, satisfactoriamente. El sistema en este punto permitió recibir instrucciones de posición desde el ordenador y controlar el dron para obedecerlas. Mediante estos cambios se consiguieron vuelos significativamente más estables y similares entre sí. Los cambios permitieron además ampliar la duración de los vuelos hasta los límites impuestos por los niveles de carga en las baterías, lo que facilitó las tareas de ajuste de parámetros PID y experimentación.
\end{itemize}

El trabajo realizado pone a disposición pública el hardware, software y diseño del sistema, listos para que cualquiera persona pueda adquirir los elementos por un bajo coste, instalarlos y ponerlos en funcionamiento. Esto ofrece un gran abanico de posibles modificaciones, mejoras y desarrollos futuros.

\section{Trabajo futuro}
\label{sec:Trabajo futuro}

El sistema desarrollado ofrece muchas posibilidades de mejoras y añadidos. En este apartado se pretenden repasar algunos de los más interesantes.

\subsection{Mejoras en la arquitectura del sistema}
\label{subsec:Mejoras en la arquitectura del sistema}

\begin{itemize}
  \item La arquitectura del sistema es posiblemente la consideración de diseño cuyo cambio tenga un mayor impacto en el resultado final. La premisa de procesar con la FPGA en tierra, tiene ventajas y desventajas. Probablemente la peor contrapartida sea los tiempos de transmisión y recepción añadidos por los distintos módulos que intervienen en la comunicación de las medidas hacia tierra y las órdenes de vuelta hacia el dron. Estos retardos añadidos, empeoran la estabilidad que se puede llegar a conseguir, con el vehículo en vuelo. El cambio más significativo pasaría posiblemente por trasladar la FPGA a la electrónica embarcada, con conexión directa a los sensores y a los drivers de los motores. Esto supondría incluir una cantidad considerable de software en la FPGA, a cambio de disminuir los retardos a más de la mitad, ganando en favor de la calidad del control que se ejerce sobre el dron.
\end{itemize}

\subsection{Mejoras hardware}
\label{subsec:Mejoras hardware}

\begin{itemize}
  \item Diseñar una única tarjeta para el sistema embarcado es una mejora que aportaría ventajas tanto con la arquitectura del sistema actual, como en caso de llevar la FPGA a bordo. En ambos casos, la disminución de peso y las mejoras en la fijación de la electrónica, favorecerían que hubiese menos interacción entre ejes (debido al error de colocación de los sensores de flujo y de altura) y que la potencia entregada por los motores fuese más holgada, mejorando la estabilidad y ahorrando batería.
  
  \item A parte de cambios sobre el sistema, se pueden plantear añadidos de interés para el sistema final, como podrían ser un conjunto de magnetómetros de 2 ejes (ubicados de manera horizontal) para medir el error de giro, lo que permitiría corregirlo, a la vez de ganar un parámetros de orientación global. También se podría incluir una cámara dependiendo del peso liberado al rediseñar la electrónica, lo cual mezcla bien con proyectos que hacen uso de ubicación local en base a reconocimiento de etiquetas por imagen. Ambas mejoras ofrecerían más capacidad de vuelo autónomo, a través de un mejor conocimiento sobre la ubicación del vehículo.
\end{itemize}

\subsection{Mejoras software}
\label{subsec:Mejoras software}

\begin{itemize}
  \item Respecto del diseño software, es difícil no encontrar maneras mejores, más eficientes de construir código igualmente funcional, una vez terminado cada módulo. Invertir tiempo en parámetros PID más ajustados, mejoras en el software existente, compactarlo, ejecutando el máximo posible sobre la FPGA (eliminando la necesidad de procesadores periféricos) y cambios de esta índole, podrían reducir los retardos de cierre de los bucles, ganando en estabilidad.
  
  \item Ampliar la librería en python es una mejora que iría en pro de la facilidad de uso. Permitiría la repetición de ensayos con menos esfuerzo.
  
  \item Los controladores actuales realizan su tarea en base exclusivamente a la posición del vehículo, pero no reparan en limitaciones de velocidad o aceleración. Una mejora potente sería ubicar bucles de control de velocidad y aceleración bajo los actuales bucles de control de posición. Esto controlaría las brusquedades y dotaría al sistema de un mayor control sobre cómo se desplaza el vehículo.
  
  \item Generador de trayectorias: Para poder acometer un generador de trayectorias completo, serían necesarias modificaciones hardware y software en la estación de tierra. Estas deberían permitir a la estación de tierra informar al ordenador de mando de la ubicación actual del dron (obtenida de las medidas de los sensores embarcados). Con este añadido se permitiría al software en el pc crear verdaderos puntos intermedios en el avance de dron, dependientes tanto de la posición actual, como de la posición de destino, trazando así una trayectoria sin incrementos exagerados en el error de los bucles de control.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BIBLIOGRAFIA %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage

\textbf{{\Large Bibliografía}}



% https://www.parrot.com/soluciones-business/profesional/parrot-sequoia
% http://www.centum-rt.com/en/lifeseeker/
% http://www.ingenieros.es/noticias/ver/life-seeker-sistema-para-la-localizaciandoacuten-de-personas-desde-el-aire/2735
% https://www.bbc.com/news/technology-38450664
% https://www.digikey.com/en/articles/techzone/2012/jul/a-designers-guide-to-mems-sensors
% https://charlestytler.com/quadcopter-equations-motion/
% https://www.infineon.com/dgdl/Infineon-Application-Motor_Control-Drone_Electronic_Speed_Controller_ESC-TR-v01_00-EN.pdf?fileId=5546d462580663ef015843a229fe54ea
% http://fpvmax.com/2017/08/09/pids-ajuste-drones/
% https://www.arrow.com/es-mx/research-and-events/articles/fpgas-in-neural-networks
% https://core.ac.uk/download/pdf/154797518.pdf
% https://www.luisllamas.es/arduino-spi/
% https://www.solitontech.com/uart-protocol-validation-service/
% https://www.st.com/en/imaging-and-photonics-solutions/vl53l0x.html
% https://www.bitcraze.io/flow-breakout/
% https://www.pixart.com/products-detail/44/PMW3901MB-TXQT
% https://hipertextual.com/presentado-por/vodafone-one/paola-santana
% https://www.amazon.com/Amazon-Prime-Air/b?ie=UTF8&node=8037720011
% http://www.automatas.org/hardware/teoria_pid.htm
% https://teslabem.com/nivel-intermedio/fundamentos-del-protocolo-i2c-aprende/
% https://teslabem.com/nivel-intermedio/fundamentos-del-protocolo-i2c-aprende/

%\begin{verbatim}
%\end{verbatim}



\cleardoublepage

% Las siguientes dos instrucciones es todo lo que necesitas
% para incluir las citas en la memoria
\bibliographystyle{abbrv}
%\bibliographystyle{apalike}
\bibliography{memoria}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ANEXOS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage

\appendix
\chapter{Mecanismos de comunicación}
\label{app:MecCom}


A lo largo de este trabajo, se hace uso de diferentes estándares y protocolos de comunicación para enlazar distintos módulos, permitiéndoles comunicarse entre ellos de una manera determinada. Aquí se comentan algunos de los mecanismos empleados en el informe.

\section{UART}
\label{sec:UART}

Se trata de un sistema de comunicaciones serie asíncronas (Universal Asynchronous Receiver Transmitter) capaz de realizar una comunicación full dúplex bidireccional con tan solo dos hilos, transmisión y recepción (más un tercero, a modo de referencia, si los dispositivos en comunicación no gozasen de una referencia común de tensión). Se utiliza cada hilo exclusivamente para cada sentido de la comunicación.\\
En el sistema se utilizan comunicaciones asíncronas en dos ubicaciones distintas. En la Figura~\ref{fig:uartframe} se muestra la transmisión de un byte que incluye bit de paridad \cite{uart_adv}. En el trabajo realizado, este bit no está en uso, el resto de la configuración es idéntica a la utilizada. Se comienza con el bus a nivel alto. El primer flanco de bajada marca la llegada del bit de inicio de paquete, ``START''. Seguido de los ocho bits de datos comenzando por el bit de menor peso ``D0'', y acabando con un último bit de parada ``STOP'', este indica el final del paquete. La línea roja del cronograma de la Figura~\ref{fig:uartframe}, muestra el instante de detección del bit de inicio, y  los posteriores instantes de muestreo de cada bit. Los bits se reciben a la tasa de transferencia preestablecida de 500Kbps, en caso contrario, se perdería la sincronía con el byte en transmisión, pudiendo perder, o recibir prematuramente el bit de parada (dependiendo de si el error en la tasa de transferencia es por exceso o por defecto), produciéndose un error de ``framing''. En caso de transferirse adecuadamente, el valor del byte estaría disponible al recibir el último bit transmitido, ``D7''.

\begin{figure}[h]
	\centering
	\includegraphics[width=14cm]{Imagenes/UART_funcionamiento.png}
	%\includegraphics[width=12cm, keepaspectratio]{Imagenes/Yaw-pitch-roll-Quadcopter.png}
	\caption{Formato de paquete UART}
	\label{fig:uartframe}
\end{figure}

\section{SPI}
\label{sec:SPI}

A lo largo del TFG se hace uso de puertos serie, SPI, en tres ubicaciones distintas, dos en la estación de tierra y la tercera en la electrónica embarcada.\\
Un puerto SPI se trata de una comunicación maestro esclavo. Esta se basa en una comunicación serie, síncrona de tres o cuatro hilos para un enlace bidireccional, con un único dispositivo cada vez \cite{spi_adv}. En la Figura~\ref{fig:spiframe} se muestra un ejemplo de comunicación, y en la Figura~\ref{fig:spiarq} un ejemplo de las conexiones. La única señal opcional es la selección del esclavo, Slave Select (SS). Las tres señales obligatorias son el reloj (SCLK), la salida de datos del maestro y entrada hacia el esclavo (MOSI) y la entrada de datos del maestro y salida del esclavo (MISO).

\begin{figure}[h]
	\centering
	\includegraphics[width=14cm]{Imagenes/spi_funcionamiento.jpg}
	\caption{Funcionamiento de una comunicación SPI}
	\label{fig:spiframe}
\end{figure}

\begin{itemize}
  \item SS: En caso de tener conexión a múltiples dispositivos, el maestro puede escoger con cual entablar comunicación, asertando este pin, activo a nivel bajo, en el esclavo deseado.
  
  \item SCLK: Se trata de la señal de reloj. Se utiliza para sincronizar las transmisiones. En el flanco de bajada se deben ubicar los datos en la salida correspondiente, y se deben leer en el flanco de subida.
  
  \item MISO: Master Input Slave Output. Convención utilizada para designar el pin de entrada de datos hacia el maestro, desde los posibles esclavos.
  
  \item MOSI: Master Output Slave Input. Ofrece la funcionalidad complementaria al pin MISO. En este caso, es el maestro el que utiliza este pin de salida y los esclavos como entrada.
  
\end{itemize}

Un esquema típico de conexión con múltiples esclavos se muestra en la Figura~\ref{fig:spiarq}. Para este trabajo, se hará uso de comunicaciones con un único esclavo únicamente, ya que se dispone de tres radios NRF24L01 y tres procesadores de Atmel independientes.

\begin{figure}[h]
	\centering
	\includegraphics[width=14cm]{Imagenes/spi_esquema.png}
	\caption{Esquema de conexión para un puerto SPI}
	\label{fig:spiarq}
\end{figure}

\section{I2C}
\label{sec:I2C}

Se trata de un desarrollo de Philips para la conexión de múltiples circuitos integrados de semejante o distinta naturaleza, sobre un bus común.\\
De manera similar al estándar de SPI, I2C hace uso de una arquitectura maestro-esclavo, síncrona, bidireccional, en este caso half-dúplex, mediante dos hilos: Reloj (normalmente designado SCL o CLK) y datos (SDA) \cite{i2c_adv} que se conectan a todos los dispositivos colgados del bus, como se muestra en la Figura~\ref{fig:i2carq}.

\begin{figure}[h]
	\centering
	\includegraphics[width=10cm]{Imagenes/I2C_Arq.png}
	\caption{Arquitectura hardware de un bus I2C}
	\label{fig:i2carq}
\end{figure}

Las líneas de reloj y datos se encuentran, por defecto, a nivel alto gracias a dos resistencias de ``pull-up'', Rp en la arquitectura arriba indicada. Para iniciar una comunicación, dichas líneas deben ser comprobadas a fin de evitar colisiones. Si el bus I2C se encuentra libre en ese instante, se puede iniciar una comunicación manteniendo la línea SCL a nivel alto y forzando un flanco de bajada en la línea de datos SDA. Este evento fuerza a los esclavos a atender el siguiente mensaje recibido, por si fuera destinado a ellos. La trama tiene el formato especificado en la Figura~\ref{fig:i2cmsg}. El destinatario se especifica en la trama enviada a través del primer grupo de 7 a 10 bits, dependiendo del dispositivo, seguido del bit que especifica el sentido de la información; se desea enviar información hacia el esclavo, o se quiere solicitar información de él. Tras cada grupo de datos transferidos, se envía un ACK o un NoACK al remitente, para informarle si el paquete ha sido recibido con éxito. La trama se termina con el envío de un bit de parada, señalado por un flanco de subida en la señal SDA, mientras se mantiene la línea SCL a nivel alto.

\begin{figure}[h]
	\centering
	\includegraphics[width=14cm]{Imagenes/I2C_Frame_Format.jpg}
	\caption{Formato de trama I2C}
	\label{fig:i2cmsg}
\end{figure}

\section{PPM}
\label{sec:PPM}

Las siglas PPM vienen de Pulse Position Modulation. Se trata de una modulación en la que cada canal tiene un instante de llegada concreto, manteniendo constantes la amplitud de los mismos \cite{PPM_adv}, respecto del canal inmediatamente anterior. El desfase que se produzca respecto de dicho instante se transforma en el valor que se asigna a ese canal. De esta manera pueden codificarse todos los canales utilizados sobre un único conductor mediante multiplexación en tiempo. El aspecto general de una trama se muestra en la Figura~\ref{fig:ppmframe}. En ella se tiene seleccionado el canal 1 para mostrar su temporización.\\
Una trama completa PPM para el dron SYMA-X5C utilizado (las características básicas de PPM se mantienen entre distintos fabricantes, pero particularidades como el número y orden de los canales puede variar) se compone de doce canales. El inicio de trama se marca con un pulso a nivel bajo de 0.3 milisegundos. A partir de este instante se comienza el conteo de cada canal, indicado por los niveles altos y separados entre ellos a por pulsos de bajada de 0.3ms. La trama termina con un último pulso de bajada de 0.3ms que indica el fin de trama. Cada canal tiene una duración mínima asignada de 1ms y una duración máxima de 2ms contando con su flanco de 0.3ms de bajada. Estos tiempos, sumados al pulso de inicio de trama, completan la duración de una trama con un máximo de 24.3ms. Cada canal por tanto tendrá su valor mínimo para una duración a nivel alto de 0.7ms (canal 1 de la Figura~\ref{fig:ppmframe}) y su valor máximo para 1.7ms.

\begin{figure}[h]
	\centering
	\includegraphics[width=14cm]{Imagenes/Mod_PPM.png}
	\caption{Señal PPM hacia el módulo de transmisión de uplink}
	\label{fig:ppmframe}
\end{figure}

En este TFG se hace uso de esta técnica, dado que el módulo que maneja esta interfaz estaba originalmente diseñado para recibir la modulación PPM de un mando de radio control. PPM es la modulación más extendida en la mayoría de mandos de radio control para conectarse a módulos externos de bandas, potencias y otras características distintas a las suyas nativas, por tanto resulta cómodo adaptarse a esta modulación, para comunicarse con el módulo de uplink.


\chapter{Sistemas de control}
\label{app:Sistemas de control}


Los sistemas de control de un dron se basan principalmente en bucles de control PID \cite{PIDs}, ejecutados por la electrónica de control antes mencionada. Estos sistemas son la herramienta principal para garantizar la estabilidad de vehículo. Los sistemas de control ejecutados dirigen la corriente en cada motor para mantener el sistema estable. Además de los sistemas comunes a todo dron, este TFG hace uso de sus propios bucles de control para conseguir su objetivo. Estos bucles, trabajan de manera simultánea y paralela a los propios del dron. A efectos del trabajo realizado, los bucles de control implementados en este TFG se consideraran los de mayor nivel, ya que son los encargados de comandar a los intrínsecos del dron, considerados de bajo nivel.\\
Los sistemas de control usados en este TFG son de dos tipos, bucle abierto y bucle cerrado, cada uno utilizado de una manera concreta en distintas partes del sistema.


\section{Bucle abierto}
\label{sec:Bucle abierto}

Los bucles abiertos reciben una señal y producen una respuesta concreta resultado de convolucionar la entrada, con la función de transferencia del bucle. Pueden ser lineales e invariantes en el tiempo, o no, dependiendo de la necesidad concreta que deban cubrir. Su respuesta es enviada hacia los actuadores, o bucles de siguiente nivel como se muestra en la Figura~\ref{fig:OpenLoop}. La respuesta del controlador de bucle abierto es independiente de la situación del dron, respuestas de sensores, posición, ubicación y demás. Por tanto, asumiendo el caso de un bucle de control abierto invariante y sin memoria, si se ejecuta en dos ocasiones con la misma señal de entrada, producirá dos veces la misma señal de salida.

\begin{figure}[h]
	\centering
	\includegraphics[width=16cm, keepaspectratio]{Imagenes/Open_loop_Controller.png}
	%\includegraphics[width=12cm, keepaspectratio]{Imagenes/Yaw-pitch-roll-Quadcopter.png}
	\caption{Esquema básico de un sistema de control de bucle abierto}
	\label{fig:OpenLoop}
\end{figure}

En relación al trabajo realizado, este tipo de bucle se usa por ejemplo en el control de la guiñada, en la cual, es un bucle cerrado de bajo nivel el que se encarga de girar lo indicado por el bucle abierto de nivel superior programado en la FPGA de control.

El comportamiento de este tipo de bucles difiere de los bucles cerrados mencionados en el siguiente punto.


\section{Bucle cerrado}
\label{sec:Bucle cerrado}

Los bucles cerrados hacen uso de dos señales de entrada. Una de ellas es el comando, es la señal que indica el objetivo a alcanzar en algún parámetro concreto por el bucle. Otra es la señal recibida de alguna otra parte del sistema o sensor, capaz de medir e informar sobre el estado del parámetro objetivo. Ambas señales se restan y producen una señal de error que es entregada al controlador \cite{closed_loop_pid}, como se muestra en la Figura~\ref{fig:ClosedLoop}. Este opera de la misma manera que para el bucle abierto, generando una respuesta que es entregada a otro módulo, ya sea un bloque de menor nivel o un actuador.

\begin{figure}[h]
	\centering
	\includegraphics[width=16cm, keepaspectratio]{Imagenes/Closed_Loop_Controller.png}
	%\includegraphics[width=12cm, keepaspectratio]{Imagenes/Yaw-pitch-roll-Quadcopter.png}
	\caption{Esquema básico de un sistema de control de bucle cerrado}
	\label{fig:ClosedLoop}
\end{figure}

Estos bucles de control si tienen en cuenta el estado actual del parámetro objetivo para realizar su corrección. Al realizar una medición sobre el mismo, pueden acomodar la respuesta del controlador a valores ajustados a la situación actual del parámetro a modificar. Pudiendo darse el caso, de que para una entrada distinta de cero, la salida del sistema hacia los actuadores, sea cero. Este sería el caso en el que el valor comandado en la entrada, es igual que el valor medido por el sensor, generando por tanto una señal de error cero (asumiendo por ejemplo una respuesta proporcional del controlador).


\section{Algoritmos de control PID}
\label{sec:Algoritmos de control PID}

Este TFG hace uso de controladores PID. Ejecuta esta clase de sistema de control a través de algoritmos que calculan el error como la diferencia entre una señal de comando (instrucción de mando desde PC) y una señal entrante (medida de un sensor). Dicho error (e(t) en la Figura~\ref{fig:PID_Controller}) entonces pasa por tres procesos paralelos.

\begin{itemize}
  \item Un proceso de proporción: Su multiplica el error por una constante proporcional según la ecuación~\ref{eq:P}. El objetivo es aproximar el error a cero a través de actuar sobre el sistema, de manera proporcional al error existente en cada evaluación del bucle.
	\begin{equation}
		P[n] = Kp \cdot e[n]
	\label{eq:P}
	\end{equation}
  
  \item Un proceso de integración: El error recibido se suma en una variable de acumulación. Esta integra la medida de error actual, junto con todas las anteriores recibidas según la ecuación~\ref{eq:I}. El resultado es multiplicado por una constante de integración. El objetivo de esta componente, es eliminar error estacionario inalcanzable para el control proporcional. Una vez regulado el valor de la constante proporcional, ocurre que cierto error sigue presente. Este error se suma a sí mismo en cada ejecución del bucle, de tal manera que la acumulación crece lo suficiente como para que se produzca una respuesta sobre los actuadores, capaz de corregirlo. Se puede deducir que una vez corregido en un caso idea, el valor del acumulador dejaría de variar.
	\begin{equation}
		I[n] = Ki \sum_{0}^{n} e[n]
	\label{eq:I}
	\end{equation}
  
  \item Un proceso de derivación: El error previamente almacenado se resta al error de este instante generando la componente derivativa de la ecuación~\ref{eq:D}. El resultado es multiplicado por una constante de derivación. Los dos bucles anteriores tienen el objetivo de corregir el error. En el desarrollo de su tarea, existe la posibilidad de que el sistema oscile. La componente proporcional puede ajustarse para trabajar fuera del régimen de sobreoscilación, pero esto no ocurre con la componente integral, la cual por definición genera un retardo en la respuesta de los actuadores que produce oscilación. Esta puede ser tan pequeña que se vuelva imperceptible, de no ser así, la componente derivativa puede ayudar a minimizar las oscilaciones. Ya que calcula la derivada del error, cuanto este cambia bruscamente, por ejemplo cuando el sistema se acerca rápidamente a la posición de la consigna, la derivada en el tiempo también crecerá, pero en sentido contrario. De tal manera que la componente derivativa ayudará entonces a frenar el sistema, dotando al controlador de un grado de suavidad en el acercamiento hacia el error. Esto disminuye las oscilaciones, por tanto se puede deducir que esta componente resultará en cero en caso de un sistema ideal sin oscilaciones, ya que el error no variaría.
	\begin{equation}
		D[n] = Kd \cdot (e[n]-e[n-1])
	\label{eq:D}
	\end{equation}
  
\end{itemize}

El resultado de los 3 procesos previos se suma en una única señal de error construyendo la señal u(t) como se muestra en la Figura~\ref{fig:PID_Controller}.

\begin{figure}[h]
	\centering
	\includegraphics[]{Imagenes/PID_Figure.png}
	%\includegraphics[width=12cm, keepaspectratio]{Imagenes/Yaw-pitch-roll-Quadcopter.png}
	\caption{Esquema de un controlador PID}
	\label{fig:PID_Controller}
\end{figure}

El resultado de la suma de la Ecuación~\ref{eq:pid} será la variable usada para tratar de corregir el error existente. Es decir, será la variable a entregar a los distintos actuadores del sistema, dependiendo de en que parte se encuentre el PID ejecutado.

\begin{equation}
	u[n] = P[n] + I[n]+D[n]
\label{eq:pid}
\end{equation}









\begin{comment}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% APÉNDICE(S) %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\cleardoublepage
%\appendix
%\chapter{Manual de usuario}
%\label{app:manual}

%Esto es un apéndice.
%Si has creado una aplicación, siempre viene bien tener un manual de usuario.
%Pues ponlo aquí.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BIBLIOGRAFIA %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage

% Las siguientes dos instrucciones es todo lo que necesitas
% para incluir las citas en la memoria
\bibliographystyle{abbrv}
\bibliography{memoria}  % memoria.bib es el nombre del fichero que contiene
% las referencias bibliográficas. Abre ese fichero y mira el formato que tiene,
% que se conoce como BibTeX. Hay muchos sitios que exportan referencias en
% formato BibTeX. Prueba a buscar en http://scholar.google.com por referencias
% y verás que lo puedes hacer de manera sencilla.
% Más información: 
% http://texblog.org/2014/04/22/using-google-scholar-to-download-bibtex-citations/

\begin{itemize}
  \item 
  
  \item 
  
  \item 
  
  \item 
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[width=5cm, keepaspectratio]{Imagenes/giro.png}
	\caption{Error de rotación}
	\label{fig:Drone_error}
\end{figure}

Figura~\ref{fig:GS_desc}

\end{comment}


\end{document}
