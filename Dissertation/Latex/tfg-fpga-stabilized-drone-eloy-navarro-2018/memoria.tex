%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Plantilla de memoria en LaTeX para la ETSIT - Universidad Rey Juan Carlos
%%
%% Por Gregorio Robles <grex arroba gsyc.urjc.es>
%%     Grupo de Sistemas y Comunicaciones
%%     Escuela Técnica Superior de Ingenieros de Telecomunicación
%%     Universidad Rey Juan Carlos
%% (muchas ideas tomadas de Internet, colegas del GSyC, antiguos alumnos...
%%  etc. Muchas gracias a todos)
%%
%% La última versión de esta plantilla está siempre disponible en:
%%     https://github.com/gregoriorobles/plantilla-memoria
%%
%% Para obtener PDF, ejecuta en la shell:
%%   make
%% (las imágenes deben ir en PNG o JPG)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper, 12pt]{book}
\usepackage[T1]{fontenc}

\usepackage[a4paper, left=2.5cm, right=2.5cm, top=3cm, bottom=3cm]{geometry}
\usepackage{times}
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel} % Comenta esta línea si tu memoria es en inglés
\usepackage{url}
%\usepackage[dvipdfm]{graphicx}
\usepackage{graphicx}
\usepackage{float}  %% H para posicionar figuras
\usepackage[nottoc, notlot, notlof, notindex]{tocbibind} %% Opciones de índice
\usepackage{latexsym}  %% Logo LaTeX
%-------Paquete para comentarios---------%
\usepackage{verbatim}
%-------Paquete para figuras---------%
\usepackage{float}
\usepackage{graphicx}
%-------Paquete para ecuaciones---------%
\usepackage{amsmath, amsthm, amssymb}


\title{Memoria del Proyecto}
\author{Nombre del autor}

\renewcommand{\baselinestretch}{1.5}  %% Interlineado

\begin{document}

\renewcommand{\refname}{Bibliografía}  %% Renombrando
\renewcommand{\appendixname}{Apéndice}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PORTADA

\begin{titlepage}
\begin{center}
\begin{tabular}[c]{c c}
%\includegraphics[bb=0 0 194 352, scale=0.25]{logo} &
\includegraphics[scale=0.25]{img/logo_vect.png} &
\begin{tabular}[b]{l}
\Huge
\textsf{UNIVERSIDAD} \\
\Huge
\textsf{REY JUAN CARLOS} \\
\end{tabular}
\\
\end{tabular}

\vspace{3cm}

\Large
ESCUELA TÉCNICA SUPERIOR DE INGENIERÍA DE TELECOMUNICACIÓN

\vspace{0.4cm}

\large
Curso Académico 2019/2020

\vspace{0.8cm}

Trabajo Fin de Grado/Máster

\vspace{2.5cm}

\LARGE
HACIENDO PROGRAMABLE Y ESTABLE CON FPGA UN DRONE COMERCIAL

\vspace{3cm}

\large
Autor : Eloy Navarro Morales \\
Tutor : Dr. José María Cañas Plaza\\
Cotutor : Juan Ordoñez Cerezo
\end{center}
\end{titlepage}

\newpage
\mbox{}
\thispagestyle{empty} % para que no se numere esta pagina


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Para firmar
\begin{comment} 
\clearpage
\pagenumbering{gobble}
\chapter*{}

\vspace{-4cm}
\begin{center}
\LARGE
\textbf{Trabajo Fin de Grado/Máster}

\vspace{1cm}
\large
Título del Trabajo con Letras Capitales para Sustantivos y Adjetivos

\vspace{1cm}
\large
\textbf{Autor :} Nombre del Alumno/a \\
\textbf{Tutor :} Dr. Gregorio Robles Martínez

\end{center}

\vspace{1cm}
La defensa del presente Proyecto Fin de Carrera se realizó el día \qquad$\;\,$ de \qquad\qquad\qquad\qquad \newline de 20XX, siendo calificada por el siguiente tribunal:


\vspace{0.5cm}
\textbf{Presidente:}

\vspace{1.2cm}
\textbf{Secretario:}

\vspace{1.2cm}
\textbf{Vocal:}


\vspace{1.2cm}
y habiendo obtenido la siguiente calificación:

\vspace{1cm}
\textbf{Calificación:}


\vspace{1cm}
\begin{flushright}
Fuenlabrada, a \qquad$\;\,$ de \qquad\qquad\qquad\qquad de 20XX
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Dedicatoria

\chapter*{}
\pagenumbering{Roman} % para comenzar la numeracion de paginas en numeros romanos
\begin{flushright}
\textit{Dedicado a \\
mi familia / mi abuelo / mi abuela}
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Agradecimientos

\chapter*{Agradecimientos}
%\addcontentsline{toc}{chapter}{Agradecimientos} % si queremos que aparezca en el índice
\markboth{AGRADECIMIENTOS}{AGRADECIMIENTOS} % encabezado 

Aquí vienen los agradecimientos\ldots Aunque está bien acordarse de la pareja, no hay que olvidarse de dar las gracias a tu madre, que aunque a veces no lo parezca disfrutará tanto de tus logros como tú\ldots 
Además, la pareja quizás no sea para siempre, pero tu madre sí.
\end{comment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen

\chapter*{Resumen}
\pagenumbering{Roman}
%\addcontentsline{toc}{chapter}{Resumen} % si queremos que aparezca en el índice
\markboth{RESUMEN}{RESUMEN} % encabezado

Dada la expansión de los drones en distintas tareas de la actualidad y del uso de las FPGAs como núcleos de procesamiento, resulta natural mezclar dichos dispositivos para beneficio mutuo.
A lo largo de este proyecto se han diseñado distintos elementos software y hardware para permitirle a un conjunto de instrucciones ejecutadas en un ordenador, controlar por completo las operaciones y trayectoria de vuelo de un drone comercial. Este es capaz de obedecer las instrucciones de posición indicadas por el programa ejecutado, sin estabilización, control ni intervención humana de por medio. Para ello se han diseñado elementos tanto en tierra, como a bordo del drone, que dotan al sistema de control autónomo sobre el vehículo. El control puede realizarse desde cualquier ordenador a través de la instalación de un paquete de librerías y la posterior ejecución de un programa en java. Todo el sistema se ha diseñado en base a FPGAs y software libres, drones de bajo coste y electrónicas concretas para cubrir cada tarea. De esta manera se dispone del control completo sobre el sistema diseñado, permitiendo mejoras y modificaciones futuras sin necesidad de incurrir en elevados costes de adquisición de software o hardware.
Tras el diseño de los distintos elementos se han realizado verificaciones de cada elemento por separado, integración y posterior verificación del sistema en su conjunto, mediante pruebas experimentales. Se han conseguido resultados especialmente satisfactorios con los sistemas en bucle cerrado, tanto en la estabilización como en el control del drone escogido.


%\begin{itemize}
%  \item ¿De qué va este proyecto? ¿Cuál es su objetivo principal?
%  \item ¿Cómo se ha realizado? ¿Qué tecnologías están involucradas?
%  \item ¿En qué contexto se ha realizado el proyecto? ¿Es un proyecto dentro de un marco general?
%\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen en inglés

\chapter*{Summary}
%\addcontentsline{toc}{chapter}{Summary} % si queremos que aparezca en el índice
\markboth{SUMMARY}{SUMMARY} % encabezado

Here comes a translation of the ``Resumen'' into English. 
Please, double check it for correct grammar and spelling.
As it is the translation of the ``Resumen'', which is supposed to be written at the end, this as well should be filled out just before submitting.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ÍNDICES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Las buenas noticias es que los índices se generan automáticamente.
% Lo único que tienes que hacer es elegir cuáles quieren que se generen,
% y comentar/descomentar esa instrucción de LaTeX.

%%%% Índice de contenidos
\tableofcontents 
%%%% Índice de figuras
\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de figuras} % para que aparezca en el indice de contenidos
\listoffigures % indice de figuras
%%%% Índice de tablas
%\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de tablas} % para que aparezca en el indice de contenidos
%\listoftables % indice de tablas


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INTRODUCCIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Introducción}
\label{chap:Introducción} % etiqueta para poder referenciar luego en el texto con ~\ref{sec:intro}
\pagenumbering{arabic} % para empezar la numeración de página con números

El desarrollo de este trabajo fin de grado está orientado a crear la infraestructura necesaria para comandar un dron mediante un conjunto de instrucciones. El sistema lo compondrán un dron, una estación de tierra y un PC. Como se ha hecho en diseños previos \cite{ordonez2019control}, se ha escogido una FPGA para el núcleo de procesamiento, ubicado en la estación de tierra.
\\
En la actualidad se ha extendido con rapidez el uso de drones y FPGAs más allá del entorno militar, en distintas áreas como vigilancia, cine, ocio, sistemas industriales, etc... Ambos dispositivos se han popularizado debido a su potencia y versatilidad de uso. La capacidad de control y guiado sobre el vehículo y su carga útil resultan tareas fundamentales, llevadas a cabo habitualmente de diversas maneras. Guiado mediante imagen \cite{DroneImagen}, tele-dirección, ubicación global y controles abiertos o por posición son algunos métodos comunes. Este trabajo se centra en el control por posición del vehículo y su guiado mediante instrucciones prefijadas. Dicho sistema ejecutará bucles de control que puede realizarse mediante distintos dispositivos, entre ellos, FPGAs \cite{ordonez2018tfg}. Ciertas características las convierten en una elección sólida como núcleo del sistema de estabilización y dirección para los múltiples grados de libertad del drone. En este TFG se hace uso de un cuadricóptero comercial como dron y FPGAs libres para cubrir las tareas de control y estabilización, fomentando además el uso y propagación de código abierto.\\
A continuación, se introducen algunas características de ambos dispositivos.


\section{Drones}
\label{sec:Sistemas básicos del drone}

Un dron hace referencia a una aeronave voladora no tripulada. Estas pueden ser pilotadas de manera remota, o mediante controles automáticos, dotándolas de distintos elementos según el mecanismo de control escogido y la tarea a cubrir.\\
Este trabajo hace uso de un cuadricóptero comercial X5C del fabricante Syma. Por tanto se mencionan algunos sistemas propios de los cuadricópteros que no se encuentran presentes necesariamente en otros tipos de drones. Algunos sistemas son específicos de cada aplicación, como puedan ser los estabilizadores de cámara usados en aplicaciones de grabación de video. Otros, por el contrario, son comunes a todos los cuadricópteros, como la estructura, sensores, electrónica de control, drivers de motores, motores y sistemas de gestión y almacenamiento de energía (baterías y reguladores). Además existen sistemas que si bien no son estrictamente necesarios para todas las aplicaciones, rara vez se ven excluidos, como son los sistemas de comunicaciones. Procedemos a comentar algunos de estos componentes del dron a continuación.


\subsection{Estructura}
\label{subsec:Estructura}

La estructura base o marco de un dron es donde apoyan y montan el resto de componentes. Sus principales requisitos son: amortiguar vibraciones, ser extremadamente rígida y ligera. Si las vibraciones no se viesen adecuadamente atenuadas, ciertas frecuencias podrían resonar mecánicamente a lo largo de toda la estructura, viendo comprometida la estabilidad del dron. Por su lado, la rigidez es fundamental, ya que para un adecuado control del dron, se necesita asumir independencia de ejes. Si partimos de una situación estable, por ejemplo, con el dron en vuelo a 1 metro de altura; si los cuatro motores generan el mismo impulso adicional (asumiéndolos ideales), en una estructura totalmente rígida el dron sencillamente ascendería. El par de rotación de las cuatro aspas se cancelaría entre sí, en caso de establecer el sentido de giro como muestra la Figura~\ref{fig:Drone}.

\begin{figure}[h]
	\centering
		\includegraphics[width=5cm, keepaspectratio]{Imagenes/Cuadricoptero_Pequeno_aspas.jpg}
		\caption{Sentido de rotación en cuadricóptero}
	\label{fig:Drone}
\end{figure}

En caso de que la estructura no resulte idealmente rígida; durante el empuje ascendente, se producirían momentos idénticos (M1, M2, M3 y M4 de la Figura \ref{fig:Drone_error}) sobre los cuatro motores, pero los ejes que unen dichos motores al marco sufrirían torsiones desiguales, lo que forzaría al dron a girar sobre sí mismo.

\begin{figure}[h]
	\centering
	\includegraphics[width=7cm, keepaspectratio]{Imagenes/Mot_Mom.png}
	\caption{Fuerzas asociadas a motores en dron}
	\label{fig:Drone_error}
\end{figure}

Dicho error de rotación podría ser corregido por otros sistemas del dron, pero solo pueden corregirse hasta cierto punto, además de ocupar dichos sistemas en corregir errores que la propia estructura puede paliar si se construye adecuadamente, pudiendo llegar a saturarlos e impedirles realizar su tarea adecuadamente.


\subsection{Sensores}
\label{subsec:Sensores}

Parte fundamental de todo cuadricóptero es un conjunto de sensores capaz de medir aceleraciones y giros. Para la mayoría de los drones comerciales, incluido el utilizado en este TFG, se hace uso de acelerómetros y giróscopos MEMS \cite{ganssle2012designer}, es decir elementos mecánicos y electromecánicos miniaturizados e integrados en solo chip. Por ejemplo un giróscopo y acelerómetro MEMS es en realidad un capacímetro diferencial conectado a un conjunto de láminas intercaladas, unas fijas al sustrato y otras libres como se muestra continuación en la Figura~\ref{fig:Masa_ST}.

\begin{figure}[h]
	\centering
	\includegraphics[width=9cm, keepaspectratio]{Imagenes/Acel_Giros_MEMS.jpg}
	\caption{Masa y capacímetros de STMicroelectronics}
	\label{fig:Masa_ST}
\end{figure}

Cuando se produce una aceleración sobre el chip, las láminas fijas al sustrato se desplazan con él, acercándose a ciertas láminas libres y alejándose de las demás, viendo por tanto su medida diferencial de capacidad alterada de manera proporcional a la aceleración, en base a la segunda ley de Newton. Esta construcción se realiza para cada eje y se integra en un solo chip, a menudo llamada plataforma inercial de tres ejes. De esta manera se facilita su integración en el sistema y se abaratan costes.\\
Como en todo, hay calidades que definen las capacidades finales de un sistema. Para el caso de una plataforma inercial la resolución es un parámetro fundamental, tanto en la medida de las aceleraciones como de los giros.\\
Podemos ilustrar el error de desplazamiento asociado a dichos sensores, cuando el sistema de control de dron se basa, por ejemplo, en un giróscopo incapaz de detectar cierto nivel de giro. Es decir, una velocidad de giro suficientemente lenta y constante como para quedar por debajo del salto mínimo de velocidad angular que el sensor es capaz de resolver, produciría un giro indetectable y por tanto incorregible para el dron. Como para el caso de la estructura, dicho error también podría ser corregido por otro tipo de sensor, pero a menudo estos no se instalan, debido al incremento del coste. Para esta situación, por ejemplo, un sensor que aplicase una posible solución sería un magnetómetro a modo de brújula, corrigiendo errores de giro mediante orientación global. Ningún dron de los utilizados en este TFG integra sistema adicional para la corrección del giro, además del propio giróscopo.


\subsection{Electrónica de Control}
\label{subsec:Electrónica de Control}

Este módulo es el encargado de procesar las señales de los sensores, entregando las respuestas necesarias para cubrir dos tareas; estabilizar el dron en giro y plano horizontal y en caso de recibir comandos por radio u otro mecanismo, modificar las órdenes a entregar a los sistemas de actuación, para obedecer. Para el caso de los cuadricópteros objeto de este trabajo, los elementos de actuación son cuatro motores, y esta electrónica deberá cubrir ambas tareas, estabilización y modificación del comportamiento en base a comandos radio recibidos desde la estación de tierra.\\
En una situación de vuelo estable, el objetivo de esta electrónica es corregir las aceleraciones y giros con las órdenes adecuadas a los motores. Por ejemplo, si un sensor detecta una aceleración a izquierdas, esta electrónica deberá responder generando una fuerza en sentido contrario, para este caso, consistirá en inclinar el dron ligera y proporcionalmente a derechas. Para ello entregará mayor indicación de velocidad de giro a los drivers de los motores izquierdos, y menor a los derechos. Con esto el dron se inclinaría, corrigiendo la aceleración que de otro modo le hubiera desplazado hacia la izquierda. Este es un caso muy simplificado a modo de ejemplo. La electrónica a bordo computa las ecuaciones de movimiento para el cuadricóptero \cite{Quad_ecuations} a la frecuencia que le permite su capacidad de proceso, junto con los tiempos de adquisición de los sensores y respuesta de los drivers y motores.


\subsection{Drivers y motores}
\label{subsec:Drivers y motores}

Este hardware es el encargado de convertir las órdenes de velocidad de giro, en giro real de las aspas conectadas a los motores. Cubren la función de transductores, instrucción a fuerza, a través de etapas de potencia que dependen de la construcción de los motores. La estructura general desde el controlador, hasta los motores, se muestra en la Figura~\ref{fig:Drivers_gen}.

\begin{figure}[h]
	\centering
	\includegraphics[width=16cm, keepaspectratio]{Imagenes/Drone_Drivers_Block.png}
	%\includegraphics[]{Imagenes/Drone_Drivers_Block.png}
	\caption{Bloques Hardware del sistema de control y drivers de un cuadricóptero}
	\label{fig:Drivers_gen}
\end{figure}

Los motores pueden ser basados en escobillas, o libres de ellas. Cada tipo de motor tiene una forma concreta de ser controlado \cite{Infi_Motors}. Los que disponen de escobillas, se manejan mediante métodos de control de motores de corriente continua. Por tanto las etapas de potencia de los drivers se despreocupan de la posición del rotor respecto del estator y transmiten mayor o menor cantidad de corriente al bobinado, a través de puentes en H controlados por PWM. Para el caso de un motor sin escobillas, hay múltiples métodos de control para producir el giro. La dificultad reside en saber en qué instante y a qué velocidad se puede variar el campo magnético en las tres fases del motor. Para ello hay algunos sistemas basados en conocer la posición relativa entre el rotor y el estator mediante sensores de efecto hall. Otros sistemas en cambio, trabajan sin dichos sensores. A efectos de este TFG, todos los motores son de corriente continua.


\subsection{Comunicaciones}
\label{subsec:Comunicaciones}

Dependiendo del tipo de dron, no es estrictamente necesario disponer de un sistema de comunicaciones radio, ya que puede ser sustituido por un conjunto de instrucciones a ejecutar a bordo del dron, sin necesidad de ver su comportamiento modificado durante el vuelo. Pero tanto para el caso de drones teledirigidos, como para el de este TFG, la radio es un componente fundamental, encargada de comunicar la electrónica del dron, con la electrónica en tierra que tiene por objetivo dirigir el dron.
Aquí rigen múltiples tipos de sistemas y estándares, el más común se encuentra en banda libre de 2.4Ghz y es en el que se apoya este TFG. Se envían comandos radio digitales en forma de tramas de doce paquetes, siendo cada paquete un canal del dron. Los cuatro canales comunes a todo dron, y utilizados en esta trabajo son: Altura (-Uz), cabeceo (pitch), guiñada (yaw) y alabeo (roll) ordenados como se muestra en la Figura~\ref{fig:YawPitchRoll}.

\begin{figure}[h]
	\centering
	%\includegraphics[]{Imagenes/Yaw-pitch-roll-Quadcopter.png}
	\includegraphics[width=12cm, keepaspectratio]{Imagenes/Yaw-pitch-roll-Quadcopter.png}
	\caption{Altura (Uz), cabeceo (pitch), guiñada (yaw) y alabeo (roll)}
	\label{fig:YawPitchRoll}
\end{figure}


\section{Aplicaciones de vehículos aéreos no tripulados}
\label{sec:Aplicaciones}

Un dron tal y como lo conocemos actualmente es una aeronave que vuela sin tripulación. Las aplicaciones de los drones son muchas, desde su inicio en el sector militar, como muchas otras tecnologías, se ha extendido su utilización a áreas de otros sectores para cubrir tareas variadas. A continuación se mencionan algunos casos interesantes.


\subsection{Agricultura}
\label{subsec:Agricultura}

Una de las áreas con mayor impacto en el desarrollo y aplicación esta siendo el sector agrícola. Con hectáreas de cultivos que controlar, y cada vez más tipos de sensores, se utilizan desde control de plagas, hasta por ejemplo, exploración de viñedos para determinar el mejor momento para la vendimia. A menudo hacen uso de controladores basados en ubicación global a través de GPS para el control de posición y trayectoria del dron, y de sensores ópticos y multiespectrales para determinar parámetros como la actividad clorofílica o su estrés hídrico. Este es el caso del sensor Sequoia+ de Parrot \cite{parrot2019parrot} de la Figura~\ref{fig:Sequo}. Dicho sensor se monta a bordo del dron que vaya a realizar la misión.
\begin{figure}[h]
	\centering
	\includegraphics[width=10cm, keepaspectratio]{Imagenes/Parrot_Sequoia.jpg}
	%\includegraphics[width=12cm, keepaspectratio]{Imagenes/Yaw-pitch-roll-Quadcopter.png}
	\caption{Sensor óptico Sequoia+}
	\label{fig:Sequo}
\end{figure}
De esta manera se analiza desde el cielo, por ejemplo, cuanta luz absorben y reflejan las plantas, permitiendo optimizar la producción del agricultor.


\subsection{Seguridad y rescate}
\label{subsec:Seguridad y rescate}

Debido a la ventaja de volar a alturas inferiores que las de un helicóptero, se ha extendido el uso de los drones al rescate de personas. Integrando cámaras de alta resolución en los mismos, y sistemas de localización de desaparecidos, como es el caso del proyecto de seguridad ``LifeSeeker'' \cite{Lifeseeker} de Centum se podría ubicar a personas desaparecidas. El dispositivo de la Figura~\ref{fig:Lifeseeker} ha sido diseñado para instalarse en aviones no tripulados \cite{Lifeseeker_Noticia}. El sistema embarcado hace uso de los móviles de los desaparecidos, aun fuera de las zonas de cobertura, como si se tratasen de radiobalizas, permitiendo así su localización.

\begin{figure}[h]
	\centering
	\includegraphics[width=10cm, keepaspectratio]{Imagenes/LifeSeeker.png}
	%\includegraphics[width=12cm, keepaspectratio]{Imagenes/Yaw-pitch-roll-Quadcopter.png}
	\caption{Módulo LifeSeeker de Centum}
	\label{fig:Lifeseeker}
\end{figure}

Otros ejemplos de sistemas basados en drones, los han utilizado para reparto masivo de medicamentos o incluso envíos de sangre para transfusiones \cite{Envio_Sangre_drone}.


\subsection{Envíos}
\label{subsec:Envios}

En esta aplicación, ha habido controversia relacionada con el control aéreo. La legislación actual dificulta el desarrollo en esta industria a la misma velocidad que se han expandido los drones en otras áreas. No obstante empresas como DHL o Amazon han desarrollado tecnologías al respecto \cite{Drone_env} y las han probado e implantado en zonas en las que dichas limitaciones no funcionan de la misma manera. A través de este servicio, Amazon envían paquetes en tiempo inferiores a los 30 minutos usando drones como el de la Figura~\ref{fig:AmaDrone}. Son sistemas híbridos con despegue vertical y vuelo horizontal. Gozan de navegación autónoma guiada por GPS y controlan el espacio aéreo a su alrededor mediante visión artificial, para evitar obstáculos y localizar su área de aterrizaje.

\begin{figure}[h]
	\centering
	\includegraphics[width=12cm, keepaspectratio]{Imagenes/prime-air_04.jpg}
	%\includegraphics[width=12cm, keepaspectratio]{Imagenes/Yaw-pitch-roll-Quadcopter.png}
	\caption{dron de Amazon en prueba real de envío}
	\label{fig:AmaDrone}
\end{figure}


\section{FPGA}
\label{sec:FPGA}

Las siglas hacen referencia a un array de puertas lógicas reprogramables in situ (Field Programmable Gate Array). Son la evolución de una tecnología previa similar llamada CPLD, que gracias a una reordenación de los elementos que las componían, consiguen una mayor densidad de puertas lógicas por centímetro cuadrado.\\
Una FPGA es un dispositivo que agrupa elementos capaces de realizar pequeñas operaciones lógicas y almacenar sus resultados en biestables. Dichas operaciones lógicas y memorias pueden interconectarse de manera muy flexible, permitiendo llevar a cabo operaciones y tareas mucho más complejas. Su programación se realiza a través de lenguajes de descripción de hardware, orientados a trabajar a bajo nivel. Para el caso de este trabajo se ha hecho uso de Verilog 2001. Un lenguaje similar a C en aspecto, pero con un concepto de fondo radicalmente distinto. A continuación se comentan algunas características y aplicaciones actuales de las FPGAs.

\subsection{Características}
\label{subsec:Características}

Una FPGA dispone de ciertas características que le ofrecen ventaja sobre opciones programables más tradicionales, como procesadores secuenciales. Estas pueden ser programadas de tal manera que ejecuten un conjunto de instrucciones concreto varias veces en paralelo, sin ver disminuido su rendimiento global, ni impactar en otros módulos pre-programados. Para un procesador secuencial, realizar la misma tarea dos veces, supone esperar a que la primera acabe para ejecutar la segunda, o disponer de hardware dedicado por duplicado, construido sobre el mismo silicio, opción no siempre disponible. Una FPGA, en cambio, es capaz de construir el mismo sistema hardware tantas veces como recursos hardware disponga, permitiendo que todos ellos ejecuten en paralelo, con un detrimento del rendimiento mínimo y controlable. Esta ventaja es de especial importancia en procesos de control cuya tarea puede dividirse en muchas, como en procesamiento de imágenes, o sistemas de procesado digital de señales. El segundo caso está muy relacionado con este TFG, debido a la ejecución simultanea de múltiples sistemas de comunicaciones, junto con cuatro bucles de control PID paralelos.\\
Otra potente característica es su capacidad de re-configuración dinámica. Esta les ha otorgado popularidad en aplicaciones en las que se requiere rediseñar por completo el sistema de procesado, sin necesidad de un cambio físico sobre el hardware. Permiten modificar, por ejemplo, un filtro completo, no solo el valor de sus coeficientes; o reordenar los módulos de un sistema de telecomunicaciones, dotándolo de funciones completamente diferentes en base a una arquitectura radicalmente nueva. Características como esta hacen que estos dispositivos se popularicen para nuevas aplicaciones.

\subsection{Aplicaciones}
\label{subsec:Aplicaciones}

Como se ha mencionado antes, las FPGAs cubren un espectro muy grande de aplicaciones, ya que van desde las típicas sustituciones de sistemas digitales combinacionales, a núcleo de sistemas paralelos, en ocasiones inabordables para un procesador secuencial estándar.\\
Algunas aplicaciones potentes a día de hoy para FPGAs son, por ejemplo, la visión artificial, procesos industriales o procesador de redes neuronales \cite{FPGAs_Neurals}. Estos últimos a menudo se han llevado a cabo por procesadores gráficos que, en su esencia, son una mezcla de muchos pequeños procesadores pensados para realizar cómputos geométricos simples. En ocasiones se están sustituyendo por FPGAs debido a la flexibilidad, potencia y capacidad de re-configuración de las mismas \cite{zhu2003fpga}. Los avances en unidades de procesamiento gráfico, a menudo no alcanzan a cubrir las necesidades de dichas redes y  dispositivos FPGA equivalentes en potencia, suelen disponer de mayor eficiencia energética y facilidad para el clustering.\\
Gracias a su robustez son también utilizadas en entornos de seguridad como los ferroviarios, e incluso comienzan a invadir entornos menos comunes, como el espacial.


\subsection{FPGAs Libres}
\label{subsec:FPGAs Libres}

Son aquellas en las que se encuentra disponible toda la información de su diseño interno, formatos de almacenamiento de datos (BitStream) y en general todo aquello necesario para que un diseñador sea capaz de crear las herramientas de software necesarias para programar dichos dispositivos.\\
En la actualidad muchas de las herramientas de diseño software para FPGAs son software propietario con un elevado coste de adquisición. Sobre todo aquellas versiones de los entornos integrados de desarrollo que incluyen la mayor cantidad de comodidades, módulos IP pre-compilados y herramientas posibles. Este es el caso de Quartus, distribuido por Intel para sus FPGAs, que incluye una versión gratuita, muy limitada de prestaciones y capacidades, o Vivado de Xilinx, en una situación similar. En contraposición a este tipo de software se encuentra el software libre, o abierto, en general englobado bajo licencias GPL (General Public License) que tienen por objetivo defender su libre distribución sin necesidad de adquirir licencias de pago. Bajo este tipo de licencias se encuentra software como Icestudio (Figuras~\ref{fig:icelogo}), orientado al diseño de software para FPGAs de Lattice, en entornos gráficos con editor de texto, o esquemas de bloques como en la Figura \ref{fig:icestudio}, en constante crecimiento. Una de las familias de FPGAs recientemente cubiertas por este software son las ICE40 UltraPlus, concretamente la ICE40UP5K. Esta FPGA es la utilizada para desarrollar el procesador de la estación de tierra durante el desarrollo de este TFG, que se detallará más adelante en este informe.

\begin{figure}[h]
	\centering
	\includegraphics[width=12cm]{Imagenes/Ice_Studio_Logo.png}
	%\includegraphics[width=12cm, keepaspectratio]{Imagenes/Yaw-pitch-roll-Quadcopter.png}
	\caption{Logo de Icestudio, IDE para desarrollo de software en FPGAs libres}
	\label{fig:icelogo}
\end{figure}

\begin{figure}[h]
	\centering
	\includegraphics[width=12cm]{Imagenes/Ice_Studio_IDE.png}
	%\includegraphics[width=12cm, keepaspectratio]{Imagenes/Yaw-pitch-roll-Quadcopter.png}
	\caption{Captura del entorno Icestudio}
	\label{fig:icestudio}
\end{figure}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OBJETIVOS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage % empezamos en página impar


\chapter{Objetivos}
\label{chap:objetivos}

Habiendo ubicado los elementos principales con los que se trabajará durante este desarrollo, procedemos a concretar y comentar el objetivo del TFG. Adicionalmente, los subobjetivos pretenden desgranar el objetivo principal en logros más concretos, que juntos, permitirán alcanzar el objetivo principal.

\section{Objetivo principal}
\label{sec:objetivo-ppal}

En este trabajo, se pretende estabilizar y programar el control de un dron comercial de bajo coste haciendo uso de FPGAs libres. El sistema; deberá ser capaz de estabilizar el vehículo de manera autónoma, haciendo uso de electrónica de sensorización embarcada en el dron y computación sobre la FPGA en tierra. Adicionalmente, el dron deberá obedecer las instrucciones de movimiento ejecutadas en el PC, en comunicación con la FPGA.


\section{Sub-objetivos}
\label{sec:Sub-objetivos}

A continuación se enumeran los tres objetivos cuyas funcionalidades, en conjunto, permitirán alcanzar el objetivo principal.

\subsection{Enriquecer dron comercial}
\label{subsec:Enriquecer dron comercial}

Se deberá nutrir al vehículo con los elementos de sensorización y comunicación adecuados a la tarea. Estos deberán permitirle conocer su ubicación de manera local y establecer una comunicación con la estación de tierra, donde se ubicará la FPGA que computará y comunicará las correcciones pertinentes de vuelta.

\subsection{Estabilizar dron mediante FPGA en tierra}
\label{subsec:Estabilizar dron mediante FPGA en tierra}

Una vez diseñada la estación de tierra y establecida la comunicación con los controladores y sensores a bordo del dron, se procederá a construir el software necesario para conseguir un vuelo estacionario y estable del vehículo.

\subsection{Programar dron desde PC}
\label{subsec:Programar dron desde PC}

La estación de tierra deberá comunicarse con el PC, permitiendo a este último ejecutar instrucciones que afecten a los controladores ejecutados en la FPGA de la estación. De esta manera, el PC se convertirá en el ordenador de mando indirectamente. Este ejecutará las instrucciones que comandarán los movimientos del dron, siendo la FPGA en la estación de tierra, la encarga de que el vehículo obedezca dichas ordenes de manera estable.


\section{Requisitos}
\label{sec:Requisitos}

Los objetivos del trabajo se deberán cubrir con unos requisitos mínimos. Estos permitirán discernir cuando una tarea se ha cumplido adecuadamente para avanzar a la siguiente. Para ello se listan a continuación.

\begin{itemize}
  \item El sistema deberá ser capaz de estabilizar el dron con al menos tres grados de libertad; cabeceo, alabeo y altitud.
  
  \item Cada grado de libertad controlado deberá implementar un bucle cerrado, retroalimentado, con controlador PID.
  
  \item Dichos controladores deberán obedecer a consignas radio que permitan el control en tiempo real desde la plataforma en tierra.
  
  \item Para facilitar las tareas de estabilización y otorgar flexibilidad al sistema, los controladores PID deberán disponer de parámetros re-configurables también desde la estación de tierra.
\end{itemize}

Para cubrir estos requisitos, se han planteado una metodología y un plan de trabajo a seguir, comentados a continuación.

\section{Metodología}
\label{sec:Metodología}

Para realizar el seguimiento del trabajo, se intentarán tener reuniones semanales por conferencia, informando de los avances y posibles problemas. También se informará por correo u otros medios en caso de resultar útil. En estas reuniones se comentará el avance y problemas y se propondrán posibles soluciones y siguientes tareas a abordar.\\
El trabajo se organizará segmentando el objetivo semanal en tareas más simples. Se diseñarán soluciones para dichas tareas y posteriormente se implementarán y testearán. Según los resultados de los ensayos, se corregirán errores, se buscarán y aplicarán soluciones alternativas y se volverá a ensayar. En caso de resultado positivo, se preparará el resultado para informar adecuadamente en la reunión, y recibir información de vuelta.


\section{Plan de trabajo}
\label{sec:Plan de trabajo}

Para conseguir alcanzar el objetivo final, cubriendo los requisitos mínimos, se procederá a abordar el trabajo con la siguiente ordenación de tareas:

\begin{itemize}

  \item Enlace con el dron: Se trara del punto de partida del proyecto. Pasa por ser capaces de realizar una comunicación radio entre un ordenador y el propio dron. Para esta tarea se hará uso del software libre provisto por goebish en su repositorio nrf24\_multipro. Habrá que conseguir enlazar el software ejecutado en un procesador de Atmel, con la electrónica propia del dron.
  
  \item Comunicación de órdenes fijas al drone: Una vez establecida la comunicación es el momento de generar el software necesario tanto para el procesador de Atmel como para la FPGA. Con esto se podrán probar instrucciones fijas, simples hacia el dron, por ejemplo una prueba de arranque, enciende y apaga motores.
  
  \item Diseño de librerías de control para PC: El objetivo de las librerías, es facilitar el uso del dron y la repetitividad de los ensayos a través de abstraerse de la capa más baja del control del dron. Esto permite pasar de instrucciones simples e independientes, a instrucciones complejas, compuestas a su vez de secuencias de instrucciones simples. Por ejemplo, despegue y aterrizaje, giros o desplazamientos. Esto facilitará las siguientes tareas.
  
  \item Comando del dron en bucle abierto: En este punto ya se dispone del software para realizar ensayos de vuelo con el dron en bucle abierto. Se encadenarán varias instrucciones de vuelo construidas en la librería previa, con el objetivo de probar el dron en trazados más complejos. Como despegue, avance, retorno y aterrizaje, o estabilidad en vuelo estático.
  
  \item Diseño de electrónica de a bordo: Para poder corregir el comportamiento en vuelo del dron, será necesario que este disponga de información relativa a su posición local. Para cubrir esta tarea, se instalará en el dron electrónica capaz de medir parámetros de posición y transmitirlos a la estación de tierra para ser procesados.
  
  \item Diseño de la estación de tierra: Para proceder a realizar ensayos de bucle cerrado, será necesario tener disponible una electrónica en tierra capaz de recibir las medidas de los sensores de a bordo. Deberá entonces poder procesarlas y transmitir la respuesta hacia el vehículo. Dicha respuesta dependerá tanto de las medidas de los sensores del dron, como de las indicaciones recibidas desde el ordenador de mando.
  
  \item Cierre de bucles para cada eje: Se deberán diseñar bucles de control independientes para cada eje en la FPGA de la estación de tierra. Esto permitirá la estabilización y manejo completo del dron.
  
  \item Experimentación y parches: Este punto cubre una necesidad presente en cada tarea. Tras aplicar cambios software y/o hardware se testeará el trabajo. Según el resultado, se avanzará a la siguiente fase del desarrollo, o se iterará entre la fase de origen y esta, hasta corregir adecuadamente los posibles errores.
  
\end{itemize}

Estas tareas se llevarán a cabo en gran medida los fines de semana, añadiendo horas tras el horario laboral, dependiendo de la disponibilidad. Para cubrir las tareas, se hará uso de las herramientas de desarrollo disponibles, comentadas a continuación en el Capítulo~\ref{chap:Infraestructura utilizada}. En base a estas, se planteará una arquitectura de sistema, definida más adelante en la Sección~\ref{chap: Módulos del sistema}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INFRAESTRUCTURA UTILIZADA %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage % empezamos en página impar
\chapter{Infraestructura utilizada}
\label{chap:Infraestructura utilizada}

Para alcanzar los objetivos, desarrollando las tareas comentadas anteriormente, hemos utilizado un amplio conjunto de herramientas software y hardware. Estas nos han permitido realizar diseños software en distintos lenguajes, compilar, programar y ejecutar, en las plataformas disponibles. Posteriormente, mediante el uso de herramientas adicionales, se han podido simular y evaluar los resultados, permitiendo avanzar a través de tareas de depuración y corrección de errores. A continuación se describen dichas herramientas y su uso durante este trabajo.


\section{Entornos de desarrollo}
\label{sec:Entornos de desarrollo}

En este apartado, se comentan las herramientas software que permiten trabajar con código, cubriendo múltiples necesidades (edición, compilación, enlazado, etc...) en un solo paquete.

\subsection{IceCube2}
\label{sec:IceCube2}

En su versión 2017.08.27940, es el entorno de desarrollo suministrado por Lattice para la programación de sus familias de pequeñas FPGAs. Integra un editor de texto plano, junto con un sintetizador para código Verilog 2001. También realiza las tareas de ubicación de elementos lógicos utilizados, trazado de conexiones en el array de la FPGA escogida y generación del fichero de programación ``*.bin''. Se ha utilizado durante todo el desarrollo sobre FPGA del trabajo. Con él se han realizado todas las tareas desde la compilación del proyecto completo hasta la generación del fichero de programación.

\subsection{Quartus Prime}
\label{sec:Quartus Prime}

Versión 15.1.0 Build 185. Herramienta de diseño, test, depuración y programación de software para FPGAs de Altera (Intel). Utilizado en este trabajo exclusivamente por su editor de texto con reconocimiento del leguaje Verilog 2001 e identificación de estructuras con color. La comodidad y versatilidad de su editor integrado, frente al entorno de Lattice, lo han convertido en mi elección para el desarrollo del código de cada módulo, previo a su compilación en el proyecto, tarea realizada con el IDE de Lattice.

\subsection{Arduino IDE}
\label{sec:Arduino IDE}

Versión 1.8.8. Entorno de desarrollo integrado de Arduino para procesadores Atmel compatibles. Adicionalmente al editor de texto, compilador, enlazador y programador, suministra algunas herramientas adicionales de utilidad:
Instalador de librerías integrado. Utilizado en el TFG para facilitar la instalación de paquetes de comunicación por puerto serie y manejo de dispositivos desde librerías en Github. Entre los incluidos, se hace uso en este trabajo de las librerías para puertos serie SPI, I2C y UART y librerías para manejo de sensores.
Además incluye un monitor de puerto serie ya configurado para el dispositivo concreto a programar. Realiza la lectura por el mismo puerto USB utilizado para programar el dispositivo, ahorrando tiempo y disminuyendo el peso necesario en la electrónica de a bordo para realizar tareas de diagnóstico. Este entorno se ha utilizado mayoritariamente para el desarrollo, depuración y programación de los programas ejecutados en los procesadores Atmel ubicados a bordo del dron (comunicación y sensores) y en la estación de tierra (comunicación por radio).


\section{Herramientas de Simulación}
\label{sec:Herramientas de Simulación}

En este apartado se comenta la única herramienta de simulación utilizada en el proyecto, ModelSim. Versión 10.4b. Herramienta para la simulación de lenguajes de descripción de hardware en general. Compatible con Verilog 2001, permite la comprobación de sintaxis del lenguaje, compilación e instanciación de múltiples módulos. En cuanto a la simulación utilizada, es una herramienta flexible en la creación de cronogramas y selección de señales a observar. Ofrece también completa configuración de resoluciones y tiempos de simulación, junto con la posibilidad de realizar análisis dinámicos del hardware definido. Gracias a su uso, se ha ahorrado tiempo a la hora de realizar tareas de limpieza de código y pruebas fuera del vehículo, disminuyendo el tiempo de desarrollo y la cantidad de choques por errores de diseño en los controles de vuelo.


\section{Herramientas de programación}
\label{sec:Herramientas de programación}

Una vez generados y simulados los códigos, estos deben ser programados en los distintos dispositivos que componen el sistema. La programación de los procesadores de Atmel se realiza a través del propio entorno de desarrollo comentado anteriormente en el apartado \ref{sec:Arduino IDE}, el resto de herramientas necesarias para programación se comentan a continuación.

\subsection{FT\_Prog}
\label{sec:FT_Prog}

Versión 3.6.88.402. Herramienta distribuida por FTDI Chip para reconfigurar la memoria flash de los dispositivos de comunicación USB, que permite modificar el comportamiento de cada canal de sus dispositivos; activando, desactivando o modificando su comportamiento para hacerlo acorde a distintos estándares. Se ha utilizado para configurar los dos canales de comunicación USB de la estación de tierra. Configurando el canal A para permitir la programación del dispositivo FPGA y el canal B para comunicar, FPGA con PC mediante USB.

\subsection{Diamond Programmer}
\label{sec:Diamond Programmer}

Se trata de la herramienta de programación distribuida por Lattice. Versión 3.10.0.111.2. Permite la programación de sus dispositivos FPGA mediante el uso de ficheros con formato ``.bin'' generados tras el trazado de la FPGA. Dicho fichero es generado, en este TFG, por la herramienta IceCube2 \ref{sec:IceCube2} y posteriormente cargado con este software para programar la FPGA de la estación de tierra.


\section{Herramientas de depuración}
\label{sec:Herramientas de depuración}

Para facilitar la detección y corrección de errores, se ha utilizado una herramienta de análisis de señales digitales, compuesta de un elemento hardware y otro software. A continuación se describen ambos.

\subsection{Logic Analizer}
\label{sec:Logic Analizer}

Tarjeta de adquisición de Saleae. Trabaja como analizador lógico de ocho canales, con muestreo hasta 24MSPS, permite la adquisición y análisis de señales de hasta 12MHz. Sus ocho canales son reconfigurables como señales de entrada y señales de disparo, facilitando la sincronía con tramas y eventos. Esta herramienta trabaja en conjunto con la interfaz de usuario ``Logic'' \ref{sec:Logic}. Sus ocho conexiones se han realizado en distintos puntos de la estación de tierra. Su función durante el desarrollo ha sido poder obtener las capturas más representativas posibles de lo que estaba ocurriendo en cada momento. Para ello, se han capturando tramas desde el PC de mando hacia la estación de tierra, medidas de los sensores desde el dron hacia la estación de tierra, señales internas de la FPGA y órdenes desde la estación de tierra al dron. Este set de sondas, ha facilitado tanto el debug en vuelo, como la corrección de distintos parámetros de los controladores. Sin ellas, hubiera resultado imposible avanzar adecuadamente entre las etapas de desarrollo del TFG.

\subsection{Logic}
\label{sec:Logic}

Versión 1.2.10. Esta utilidad de Saleae es su interfaz para almacenamiento y visualización de señales, tomadas con sus herramientas hardware de análisis digital. En nuestro caso, la hemos utilizado junto con el analizador lógico ``Logic Analizer'', cubriendo las tareas comentadas anteriormente (apartado \ref{sec:Logic Analizer}). Para el caso de un puerto serie, permite el análisis de la información de un protocolo concreto, decodificando los bits de cada canal y mostrando el resultado en relación al instante de llegada. Esto hace posible tareas de depuración, basadas en observar el efecto concreto de un cambio en el código. Se pueden nombrar y configurar distintos protocolos para cada canal, de esta manera se ha utilizado también para comprobar el comportamiento de puertos UART, SPI y señales internas de la FPGA, analizando los datos transferidos entre dispositivos. 


\section{Plataformas hardware}
\label{sec:Plataformas hardware}

La arquitectura escogida para el desarrollo de este trabajo, requiere del uso de múltiples tarjetas con distintas capacidades. Estas, trabajan juntas para cumplir un mismo objetivo. Tanto en la estación de tierra, como a bordo del vehículo, se han instalado varios elementos hardware descritos a continuación.

\subsection{Arduino Uno y Nano}
\label{sec:Arduino Uno y Nano}

Como procesadores auxiliares, se han utilizado tarjetas de desarrollo, que integran un procesador de Atmel de 8 bits modelos ATMEGA8U2-MU y ATMEGA328P-AU, un interfaz de UART a USB para comunicaciones, programación y alimentación, conectores hacia las GPIOs de los procesadores y un regulador de 5 a 3,3 voltios. Se pueden alimentar de manera externa sobre la entrada del regulador, o directamente mediante el USB. Se dispone de acceso para programación y comunicaciones a través del mismo USB en ambas tarjetas. La tarjeta ``Nano'' la hemos utilizado a bordo del dron por una cuestión de dimensión y peso, mientras que la tarjeta ``Uno'', significativamente más grande y pesada, se ha quedado en la estación de tierra, junto a la FPGA.

\subsection{ICE40 UltraPlus Breakout Board}
\label{sec:ICE40 UltraPlus Breakout Board}

Tarjeta de desarrollo para la familia UltraPlus de los modelos ICE40 de Lattice. Incluye un regulador de tensión, elementos varios de interfaz humana; como Leds, interruptores, jumpers y conexiones de propósito general. También incluye un interfaz USB reprogramable de FTDI Chip y doble canal, FT232HL, con el canal A configurado para convertir de USB a SPI, ocupado en la programación y el canal B libre de uso. Como procesador dispone de una FPGA ICE40UP5K-SG48 en su encapsulado QFN de 48 pines, con 5280 celdas lógicas, 120Kbits de RAM embebida y 1024kbits de RAM estática, una PLL y 8 bloques DSP (multiplicadores de 16 bits). 
Se trata de una FPGA basada en RAM, por tanto, dispone de una memoria interna de configuración basada en RAM (bancos de memoria que determinan el hardware que se construirá dentro de la FPGA) y una memoria flash externa (instalada en esta tarjeta). Esto permite:
\begin{itemize}
  \item Configurar un programa volátil, directamente en la memoria RAM de configuración de la FPGA. Este, sobrescribirá cualquier configuración existente y desaparecerá en caso de apagado.
  
  \item Almacenar un programa en memoria flash externa, el cual será cargado en la memoria de configuración RAM, durante el arranque.
\end{itemize}
Esta plataforma se ha usado como núcleo de la estación de tierra, conectándose con periféricos radio y el PC de mando.


\subsection{SYMA X5C}
\label{sec:SYMA X5C}

Dron cuadricóptero teledirigido fabricado por Syma. Escogido por ser un dron ligero (100gr) para su tamaño (31cm de ancho y largo), con una estructura robusta. Idóneo para aprendizaje y experimentación, gracias a su importante resistencia mecánica. Su electrónica de recepción radio alcanza 50 metros en la banda de 2.4GHz, cuenta con cuatro canales de control y batería de litio. Además incluye varios elementos que han sido descartado en este TFG, para ganar relación potencia a peso. Como cámara con almacenamiento en SD-Card, iluminación y protecciones de aspas.


\subsection{NRF24L01}
\label{sec:NRF24L01}

Este módulo, integra el chip de mismo código, junto a condensadores de desacoplo necesarios para su utilización, una antena integrada en la propia PCB y pines de acceso a su interfaz SPI. Su utilización durante el trabajo ha facilitado la implementación radio, gracias a la integración en una pequeña PCB de todo lo necesario para establecer la conexión. Ocupa la banda de 2.4GHz, con 125 posibles canales de 1 MHz de ancho de banda cada uno (disponibles para multiplexación en frecuencia). Al trabajar hasta los 3.6 voltios, es perfecto para su utilización junto con las tarjetas Arduino Uno y Nano, que integran reguladores a dicha tensión. Dispone de tasas de transferencia de hasta 2Mbps y alcances de hasta 30 metros.

\subsection{Flow breakout board}
\label{sec:Flow breakout board}

Se trata de un módulo de BitCraze \cite{sensor_module}, que integra un sensor de medida de distancias por tiempo de vuelo VL53L0x, accesible por I2C, junto a un sensor de flujo óptico PMW3901, accesible por SPI. Incluye la óptica, electrónica periférica para hacerlos funcionar y un cabezal para las conexiones eléctricas. Funciona a 3.6 voltios, por lo que lo alimentamos directamente desde la salida del regulador de la tarjeta Nano, a bordo del dron. Esto también nos permite realizar el interfaz eléctrico directamente entre los procesadores y el módulo. Usamos este conjunto de sensores, ya que nos ofrece medidas del desplazamiento horizontal y vertical, en una sola tarjeta de peso y tamaño adecuados al vehículo escogido.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Módulos del sistema %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage % empezamos en página impar
\chapter{Arquitectura del sistema}
\label{chap: Módulos del sistema}

A continuación se expresa la arquitectura del sistema, en su conjunto de tres módulos principales; PC, dron y estación de tierra. Estos módulos se descomponen en elementos adicionales, explicados más adelante en sus respectivas secciones. También se detallan los interfaces que comunican dichos módulos.

\section{Estructura utilizada}
\label{sec:Arquitectura}

La estructura planteada en este TFG, pretende cubrir los objetivos propuestos en el Capítulo~\ref{chap:objetivos}, haciendo uso de la infraestructura indicada en el Capítulo~\ref{chap:Infraestructura utilizada}. Para realizar sus tareas, el sistema se compone de tres módulos principales y dos interfaces de alto nivel. La arquitectura planteada, junto con la relación entre dichos elementos, se muestran en la Figura~\ref{fig:NewSystArq}.

\begin{figure}[h]
	\centering
	\includegraphics[width=14cm, keepaspectratio]{Imagenes/Arquitectura_del_Sistema.png}
	\caption{Arquitectura de sistema}
	\label{fig:NewSystArq}
\end{figure}

Los tres módulos principales que lo componen son:

\begin{itemize}
  \item Ordenador de mando: PC utilizado para enviar hacia la estación de tierra, las instrucciones que comandarán el dron.
  
  \item Dron: Se trata del cuadricóptero que deberá obedecer las instrucciones de movimiento, indicadas por el ordenador de mando. Irá cargado de electrónica propia y sensores adicionales.
  
  \item Estación de tierra: Este módulo actuará como centro neurálgico del sistema, mediante el uso de una FPGA como núcleo. Presta atención a las instrucciones indicadas por el ordenador de mando y deberá encargarse de que el vehículo escogido, ejecute adecuadamente dichas instrucciones.
\end{itemize}

Estos elementos, se comunican entre sí gracias a dos grupos de interfaces de sistema:

\begin{itemize}
  \item Interfaz USB de mando: Conexión unidireccional encargada de portar el flujo de instrucciones desde el ordenador de mando, hacia la estación de tierra, mediante USB 2.0. Contiene las instrucciones de mando, que la estación de tierra deberá hacer efectivas.
  
  \item Interfaz radio: Enlace bidireccional que permite comunicar el dron con la estación de tierra y viceversa. Contiene las medidas de los sensores de a bordo y las órdenes de movimiento hacia el dron.
\end{itemize}


La arquitectura, del sistema propuesto, basa su funcionamiento en las siguientes premisas:

\begin{itemize}
  \item La estación de tierra, atiende los comandos que puedan llegar desde el ordenador de mando.
  
  \item El dron, cargado de sensores, transmitirá periódicamente medidas de posición hacia la estación de tierra.
  
  \item La estación de tierra, gracias a las medidas de los sensores recibidas desde el dron, es capaz de ubicar de manera local la posición del vehículo. Dicha ubicación será relativa al punto de despegue.
  
  \item La estación de tierra, generará un vector de error de posición para el vehículo en vuelo, mediante la diferencia entre las medidas de posición indicadas por los sensores del vehículo y las órdenes recibidas desde el ordenador de mando.
  
  \item La estación de tierra, transmitirá al vehículo en vuelo, ordenes de movimiento para corregir el posible error de posición existente.
  
  \item El dron, realizará cambios en su posición, en base a las ordenes de movimiento recibidas.
\end{itemize}

De manera general, este conjunto de afirmaciones es llevado a cabo, a través del flujo de control expresado en la Figura~\ref{fig:System_Flow}.

\begin{figure}[h]
	\centering
	\includegraphics[width=13cm, keepaspectratio]{Imagenes/Flujo_del_Sistema.png}
	\caption{Flujo de control general del sistema}
	\label{fig:System_Flow}
\end{figure}

Para cubrir la funcionalidad de dicho bucle, el sistema hace uso de los tres módulos indicados anteriormente (Figura~\ref{fig:NewSystArq}), comentados en los siguientes apartados.


\section{Dron enriquecido}
\label{sec:Sistema embarcado}

Se trata de la plataforma utilizada como vehículo volador. Finalmente, para el desarrollo de este TFG, se ha optado por el X5C de Syma (Comentado en~\ref{sec:SYMA X5C}), sobre el que se han realizado modificaciones en su estructura y añadidos a sus capacidades originales.\\ 
Estos añadidos le permiten:

\begin{itemize}
  \item Medir distancia al suelo, para conocer su altura.
  
  \item Medir su desplazamiento horizontal, para conocer su ubicación relativa al punto de despegue.
  
  \item Comunicarse por radio con la estación de tierra, para hacer llegar su ubicación a la FPGA allí ubicada.
\end{itemize}

A continuación se comenta la arquitectura que permite la comunicación de estas medidas de posición.


\subsection{Arquitectura del dron}
\label{subsec:OB_Desc}

Para controlar el vuelo del dron, desde la estación de tierra, es necesario nutrirla de información sobre el vehículo, que este no tenía a su disposición en origen. Resulta imprescindible, tanto que la FPGA de la estación, conozca la posición del dron; como que este sea capaz de moverse según se lo indiquen en cada instante. Esto último ya se encontraba presente entre las capacidades originales del dron, por tanto, se ha instalado electrónica adicional en el vehículo que le permite cubrir la primera necesidad, conocer su ubicación. La arquitectura final del dron se muestra en la Figura~\ref{fig:Drone_arq}.

\begin{figure}[h]
	\centering
	\includegraphics[width=14cm, keepaspectratio]{Imagenes/Drone_arq.png}
	\caption{Arquitectura del dron}
	\label{fig:Drone_arq}
\end{figure}

Esta arquitectura hace uso de múltiples elementos, como sensores, actuadores, procesadores y radios. La radio de recepción, electrónica de control y actuadores, mostrados en la rama inferior de la Figura~\ref{fig:Drone_arq}, son los elementos propios del vehículo. Estos le permiten obedecer ordenes de movimiento, dirigidas a él a través del interfaz radio de subida (Apartado~\ref{subsec:Uplink}), detallado más adelante en este informe. Los módulos de la rama superior de la arquitectura son los que dotan al vehículo en cuestión, de la capacidad de conocer su posición en tiempo real y transmitírsela a la FPGA de la estación de tierra. Estos se comentan a continuación.


\subsection{Módulos del dron}
\label{subsec:OB_Mod}

El vehículo se equipa con los siguientes módulos adicionales, utilizados para conocer su propia ubicación en tiempo real.
\begin{itemize}
  \item Módulo 1: Procesador Atmel.
  
  \item Módulo 2: Tarjeta de sensores: Sensor de flujo óptico y sensor de medida de distancias por tiempo de vuelo, integrados en una misma tarjeta.
  
  \item Módulo 3: Transmisor radio de enlace con la FPGA.
\end{itemize}

La instalación final de estos módulos sobre el X5C, se muestra en la Figura~\ref{fig:OB_desc}.

\begin{figure}[h]
	\centering
	\includegraphics[width=14cm, keepaspectratio]{Imagenes/OnBoard_System_Mod.jpg}
	\caption{Módulos 1, 2 y 3 instalados adicionalmente}
	\label{fig:OB_desc}
\end{figure}

Estos módulos se alimentan desde un pack de batería de 3.6V de Litio, independiente de la electrónica de control propia del vehículo. Esto es debido a que a pesar del peso adicional que supone una batería separada, los drivers de motores del dron exigen picos de corriente considerables a las baterías. Estas, que no siempre tienen capacidad de descarga suficiente, debido al diseño precario del dron, caen en tensión. Estas caídas, llegaban a producir apagados eventuales en la electrónica de los sensores, lo que dificulta el control, volviendo el sistema inestable en la mayor parte de los casos. Por este motivo, se optó por un conjunto separado de baterías para alimentar los tres módulos adicionales, comentados a continuación.

\subsubsection{Módulo 1: Procesador}
\label{subsubsec:OB_Mod1}

Este módulo se encarga de inicializar los dos sensores, altura y desplazamiento y realizar lecturas de sus medidas por los interfaces I2C\_Alt y SPI\_XY respectivamente. Una vez tomadas las medidas, se realizan ciertos procesos sobre los datos. El sensor de medida de altura por tiempo de vuelo (ToF) \cite{sensor_tof} sufre errores por debajo de los 3 cm, por tanto este módulo se encarga de filtrar dichos valores erróneos, entregando una medida ficticia de 3 cm para toda altura igual o inferior. Esto provoca que el dron, una vez aterrizado, siga indicando una altura de 3 cm, lo cual no supone un problema ya que llegado el momento del aterrizaje, la altura ficticia de 3 cm medidos, ayuda a descargar el bucle integral, apagando los motores por completo. También realiza las lecturas del sensor de velocidad de desplazamiento horizontal (Flow). El procesador se encarga de convertir estas, en medidas de posición. Para ello integra en el tiempo las medidas de velocidad de desplazamiento, leídas del interfaz SPI\_XY. Además, el sensor de flujo no mide correctamente para alturas inferiores a 4 cm, por tanto, para un rango inferior a este, no se  modifican las medidas de posición.\\
Una vez filtradas e integradas, el procesador entrama dichas medidas y las envía hacia la FPGA en tierra, a través de la radio del módulo 3, haciendo uso del interfaz SPI\_Radio.

\subsubsection{Módulo 2: Tarjeta de Sensores}
\label{subsubsec:OB_Mod2}

Este módulo se compone de una sola tarjeta que integra dos sensores. Juntos ofrecen lo necesario para llegar a conocer la ubicación en tiempo real del dron, relativa al punto de despegue. Incluye electrónica auxiliar y conexiones, además de los módulos de medida de distancia por tiempo de vuelo (Sensor ToF) y medida de velocidad de desplazamiento en dos ejes (Sensor de flujo).

\begin{itemize}
  \item Sensor ToF: Se trata del sensor VL53L0x, el cual mide la distancia entre su encapsulado y un objeto enfrentado a él, a través de la medida del tiempo de vuelo de una señal laser. El procesador del módulo 1, accede a sus medidas a través del interfaz I2C\_Alt, un puerto serie I2C. Tiene un rango de trabajo de entre tres centímetros y dos metros. Este sensor se apunta hacia el suelo, desde su soporte en el dron, con la intención de medir la distancia al suelo desde el punto medio del dron. De esta manera una vez aterrizado, la distancia de medida, es ligeramente superior a 3cm, lo cual minimiza la necesidad de filtrado en el procesador (esta última se mantiene igualmente, ya que los apoyos del dron son flexibles, y el sensor tiene tolerancias de medida). Este sensor tiene un retardo de medida de hasta 30ms, el cual, limita en cierta medida la estabilidad del bucle de control de altura ejecutado en la FPGA.
  
  \item Sensor  de flujo: Como sensor de desplazamiento horizontal se hace uso del PMW3901 \cite{motion_module}. Este sensor de movimiento, tiene una óptica diseñada para enfocar a distancias superiores a 8cm. Aunque funciona bien hasta los 4cm si se dispone de buena iluminación. Sus medidas son filtradas como se indica en el proceso del módulo 1 para mitigar errores de medida. Entrega medidas de velocidad de desplazamiento en dos ejes, para el plano captado por su óptica. En el montaje, el sensor se apunta hacia el suelo, desde el mismo soporte que para el sensor de tiempo de vuelo. De esta manera se conocerá la velocidad de desplazamiento horizontal del dron respecto del suelo. Es el módulo 1 el encargado de convertir estas medidas de velocidad de desplazamiento en posición relativa horizontal. La orientación de medida del sensor se muestra en la Figura~\ref{fig:BC_XY}. Desde el punto de vista del vehículo, el avance es acorde al eje \textit{-X} y el desplazamiento a izquierdas \textit{+Y}. El sensor tiene un puerto de comunicaciones SPI para inicialización y lectura, sus medidas son leídas por el procesador del módulo 1 a través del interfaz SPI\_XY.
\end{itemize}

\begin{figure}[h]
	\centering
	%\includegraphics[width=14cm, keepaspectratio]{Imagenes/BitCrazeXY.jpg}
	\includegraphics{Imagenes/BitCrazeXY.png}
	\caption{Orientación de eje horizontales en Módulo 2}
	\label{fig:BC_XY}
\end{figure}

\subsubsection{Módulo 3: Transmisor de bajada hacia FPGA}
\label{subsubsec:OB_Mod3}

El módulo se compone de una radio NRF24L01 conectada por puerto SPI al procesador del módulo 1, a través del interfaz SPI\_Radio. Esta interfaz permite tanto la configuración del dispositivo, como su uso para transmitir tramas. El integrado NRF24L01, se configura como transmisor para enviar las medidas de posición, ya procesadas y entramadas por el procesador del módulo 1, hacia la estación de tierra. Dicha transmisión ocurre de manera periódica, después de realizar cada medida de posición.

\subsection{Interfaces internos}
\label{subsec:OB_II}

En este apartado se comentan los interfaces de la rama superior de la arquitectura definida anteriormente en \ref{subsec:OB_Desc}. Estos se limitan a comunicar información, dentro de la electrónica adicional instalada en el vehículo.

\begin{itemize}
  \item I2C\_Alt: Comunica por puerto serie I2C, el sensor de medida de altura, VL53L0x del módulo 2, con el procesador del módulo 1. Porta las medidas de distancia entre la zona media del dron y el suelo bajo él, consideradas como la altura del dron.
  
  \item SPI\_XY: Comunica por puerto serie SPI, el sensor de flujo, PMW3901, del módulo 2 con el procesador del módulo 1. Porta las medidas de velocidad de desplazamiento sobre el plano horizontal en ambos ejes, derivadas del desplazamiento del suelo bajo el sensor.
  
  \item SPI\_Radio: Puerto serie SPI utilizado para la configuración inicial de la radio NRF24L01, y para la indicación de tramas a enviar. Estas contendrán las medidas de posición ya procesadas. La configuración inicial se realiza de la misma manera que para el módulo receptor en la estación de tierra. En la cual se esperan recibir las tramas enviadas desde esta electrónica a bordo del vehículo, por tanto, la configuración de ambas y el formato de las tramas, deberá ser compatible, según lo especificado en el apartado~\ref{sec: Interfaz radio}.
\end{itemize}


\subsection{Interfaces externos}
\label{subsec:OB_IE}

El vehículo solo se comunica con el resto del sistema mediante enlace radio (comentado en el apartado~\ref{sec: Interfaz radio}), a través del \textit{Interfaz Radio} de la Figura~\ref{fig:NewSystArq}, que lo conecta contra la estación de tierra. Esto permite llegar las medidas de posición a la FPGA y las órdenes de movimiento, de vuelta hacai el dron.\\
También dispone de conexión USB, exclusiva para reprogramación del procesador y extracción de medidas por puerto serie en tareas de depuración. Este no se muestra en la arquitectura del sistema del apartado~\ref{sec:Arquitectura}.


\subsection{Software a bordo del dron}
\label{sec:Software en el módulo de Downlink embarcado}

El software planteado para el dron, se ejecuta en el procesador Atmel del módulo 1. A través de los interfaces internos (apartado~\ref{subsec:OB_II}) se encarga de configurar radio y sensores, para posteriormente realizar una medida de cada sensor y transmitirlas por radio. El objetivo es mantener informada a la estación de tierra, de la posición del vehículo. Este software se diseñó para cubrir ciertos requisitos como: Consumir la menor cantidad de energía posible, realizar su función rápidamente (permite aumentar el ancho de banda), entreteniéndose lo menor posible en tareas secundarias (intentando minimizar latencias), y transmitir cada medidas rápida e íntegramente. Para cubrir estos objetivos, el software se ha diseñado de manera sencilla. Se comienza iniciando los sensores y la radio, sin modificar sus parámetros durante la ejecución y se prepara una estructura de datos en la que quepa la trama entera a transmitir por radio, en grupos de dos bytes:\\
\begin{verbatim}
struct TxFrame{
  int16_t H_disp_front;	// Frontal displacement counter
  int16_t H_disp_side;  // Side displacement counter
  int16_t altitude;     // Altitude counter
};
\end{verbatim}

Esto permite realizar una medida de cada sensor, filtrarlas y almacenar el resultado sobre su respectiva ubicación en la variable tipo \textit{TxFrame}. Esta entonces, puede transmitirse inmediatamente por radio, minimizando retardos e iterando esta lógica en bucle, hasta el apagado de la electrónica.


\section{Estación de tierra basada en FPGA}
\label{sec: Estación de tierra}

Este módulo, hace posible que el vehículo escogido, obedezca las instrucciones ejecutadas en el ordenador de mando (apartado~\ref{sec: Ordenador de mando}). Además resulta fundamental poder realizar capturas de información en tiempo real, para el ajuste de los distintos parámetros que intervienen en el control del vuelo del vehículo. Por tanto, se instala un conjunto de electrónica que otorgue suficientes capacidades a la estación de tierra:

\begin{itemize}
  \item Atender las tramas de mando enviadas desde PC por USB.
  
  \item Atender las tramas con medidas de posición enviadas desde el dron por radio.
  
  \item Ejecutar algoritmos de control, para generar órdenes de movimiento que estabilicen y manejen el vehículo.
  
  \item Transmitir por radio ordenes de movimiento hacia el dron.

  \item Realizar capturas de valores internos de la FPGA y tramas de comunicaciones, enviándolos después hacia el PC para su análisis.
\end{itemize}

Para cubrir este conjunto de tareas, se converge en la siguiente arquitectura.

\subsection{Arquitectura de la estación}
\label{subsec:GS_Desc}

La estación de tierra se estructura de manera que sea capaz de realizar las tareas comentadas. Hace uso de una FPGA de Lattice ubicada en la tarjeta de desarrollo escogida (\ref{sec:ICE40 UltraPlus Breakout Board}), dos módulos radio (\ref{sec:NRF24L01}) y un módulo de adquisición para depurar señales digitales (\ref{sec:Logic Analizer}). Estos elementos le permiten, no solo dirigir el dron, sino además facilitar tareas de ensayo y error, permitiendo ajustar los controladores. En la Figura~\ref{fig:ETArq} se exponen los módulos y relaciones entre ellos, que intervienen para cumplir dichas tareas.

\begin{figure}[h]
	\centering
	\includegraphics[width=16cm, keepaspectratio]{Imagenes/ET_arq.png}
	\caption{Arquitectura de la estación de tierra}
	\label{fig:ETArq}
\end{figure}

A continuación se explican los módulos que hacen posible los cometidos desempeñados por la estación de tierra.

\subsection{Módulos de la estación}
\label{subsec:GS_Mod}

Para el control y depuración del vuelo del dron, la estación se equipa con los siguientes módulos:

\begin{itemize}
  \item Módulo 1: Concentrador USB (HUB USB), como enlace hacia el PC.
  
  \item Módulo 2: Tarjeta de procesamiento basada en FPGA (FPGA), para ejecución de algoritmos de control.
  
  \item Módulo 3: Receptor radio (Módulo RX), de las medidas de posición del dron.
  
  \item Módulo 4: Transmisor radio (Módulo TX), de las órdenes de movimiento hacia el dron.
  
  \item Módulo 5: Módulo de Depuración, para adquisición de señales digitales.
\end{itemize}

Cada módulo de la estación, se compone de una o varias tarjetas mostradas en el montaje de la Figura~\ref{fig:GS_desc}. Cada módulo ejecuta con una función concreta y necesaria para cumplir algún sub-objetivo, permitir a las demás cumplir con el suyo, o facilitar las tareas de depuración.

\begin{figure}[h]
	\centering
	\includegraphics[width=16cm, keepaspectratio]{Imagenes/Ground_Station_Mod.jpg}
	\caption{Montaje de la estación de tierra}
	\label{fig:GS_desc}
\end{figure}

A continuación se describen los distintos módulos que componen la estación de tierra, enumerados en la Figura~\ref{fig:GS_desc}:

\subsubsection{Módulo 1: Concentrador USB}
\label{subsubsec:GS_Mod1}

Centraliza las comunicaciones USB, permitiendo tener un único puerto ocupado en el PC y poder acceder desde él a la programación individual de los 3 módulos reprogramables; modúlo transmisor, modulo receptor y FPGA. Además se puede acceder a las sondas de depuración, y alimentar simultáneamente todos los sistemas. También permite el apagado individual de cada módulo, muy útil para restablecer la comunicación con el dron reiniciando el módulo transmisor, sin eliminar la configuración en RAM existente en la FPGA.

\subsubsection{Módulo 2: Procesador basado en FPGA}
\label{subsubsec:GS_Mod2}

Se trata de la tarjeta que integra la FPGA utilizada como procesador principal del sistema. Incluye la Lattice comentada en el Apartado~\ref{sec:ICE40 UltraPlus Breakout Board} junto a demás elementos periféricos y auxiliares. Se conecta con el ordenador de mando mediante el interfaz USB integrado en el chip FT232HL, cuyo canal B se encuentra libre. Este convierte de USB a UART, para comunicar las instrucciones de mando desde el PC hacia la FPGA.\\
La FPGA de este módulo es la encargada de atender las instrucciones de mando y las medidas de los sensores de a bordo del dron. Además se encarga de ejecutar los bucles de control, generando las órdenes de movimiento que corregirán la trayectoria del vehículo. Estas las modula mediante modulación por posición de pulso, sobre el interfaz Tramas\_PPM, hacia el módulo transmisor. Más adelante se describen los algoritmos de control utilizados (Apartado~\ref{sec:Algoritmos de control sobre la FPGA}).

\subsubsection{Módulo 3: Receptor radio de medidas de posición}
\label{subsubsec:GS_Mod3}

Se compone de una radio NRF24L01 conectada por puerto SPI a un procesador de Atmel integrado en la tarjeta Arduino Uno. La radio se alimenta desde la tarjeta del procesador, el cual se alimenta a su vez por USB. También se tiene acceso por dicho USB a la reprogramación del procesador y a su salida de puerto serie para depuración.\\
Este módulo se encarga de recibir las medidas de posición desde los sensores a bordo del dron. Configura la radio como receptora y se mantiene atento por pollin, a la espera de recibir nuevas medidas de posición desde el vehículo. Una vez recibidas, las entrama y las dirige (Byte a Byte mediante protocolo UART) hacia la FPGA del módulo 2 mediante la interfaz UART\_Sensores del Apartado~\ref{subsec:GS_II}.

\subsubsection{Módulo 4: Transmisor radio de órdenes de movimiento}
\label{subsubsec:GS_Mod4}

Este módulo se encarga de demodular el interfaz Tramas\_PPM, contenedor de las órdenes de movimiento indicadas por la FPGA. Convierte dicha modulación en una transmisión radio hacia el dron. Consta de un procesador de Atmel integrado en una tarjeta Arduino Nano, junto con una radio NRF24L01. La tarjeta Arduino Nano, incluye también regulador de tensión e interfaz USB para cubrir las mismas tareas que en el caso del módulo 3, alimentación, depuración y programación. El procesador configura la radio como transmisor y la enlaza con la electrónica original del dron (Rama inferior de la arquitectura de la Figura~\ref{fig:Drone_arq}). Tras el enlace, comienza a transmitir periódicamente hacia el dron, las órdenes de movimiento demoduladas de la trama PPM recibida desde la FPGA.

\subsubsection{Módulo 5: Depuración}
\label{subsubsec:GS_Mod5}

Se trata de un sistema de adquisición digital diseñado por Saleae, para ser usado como analizador lógico. Dispone de una conexión de masa como referencia y ocho canales. Estos se conectan de tal manera que se tiene acceso a la información de los interfaces: UART\_Mando (Órdenes de movimiento recibidas desde el ordenador), UART\_Sensorses (Medidas de posición recibidas desde la electrónica de sensorización del dron), Tramas\_PPM (tramas con modulación PPM generadas por la FPGA, encapsulando los resultados de sus bucles de control) y algunas señales internas de la FPGA. De esta manera, se puede depurar el sistema completo una vez en funcionamiento. Ya que el sistema de adquisición de Saleae permite capturas predefinidas en tiempo, se configuran adquisiciones de 5 o 10 segundos y se asocia el disparo de captura a la recepción de una nueva trama desde el ordenador de mando. De esta manera, se realizan capturas de todos los eventos que se producen en el entorno de la orden enviada. Esto ha hecho posible gran parte de la depuración de errores y fallos en la estabilidad del sistema o en su ejecución, junto con ajuste de parámetros PID.


\subsection{Interfaces internos}
\label{subsec:GS_II}

Para comunicar información entre los módulos propios a la electrónica de la estación de tierra, se han definido un conjunto de interfaces mostrados en la Figura~\ref{fig:ETArq}. Estos son:

\begin{itemize}
  \item UART\_Mando: Comunica el USB del ordenador de mando, con la FPGA (mediante el intercambiador de protocolo USB a UART, FT23HL). una vez convertido a protocolo UART, se trata de una interfaz asíncrona sin paridad ni control de flujo, con 10 bits por byte y una tasa de transferencia de 500Kbps. Aquí se incluyen las instrucciones ejecutadas en el PC, que comandarán el vuelo del vehículo.
  
  \item UART\_Sensores: La segunda de las interfaces asíncronas utilizadas en la estación de tierra, hace uso de una UART configurada idénticamente a la utilizada en el interfaz \textit{UART\_Mando}. Esta, porta las medidas de posición recibidas desde el dron, por el módulo receptor, con destino en la FPGA.
  
  \item Tramas\_PPM: Esta interfaz comunica las órdenes de movimiento, enviadas por la FPGA, con el módulo transmisor (el cual se hará responsable de hacerlas llegar a su destino final, el dron). Para ello, hace uso de un único hilo con modulación por posición de pulso. En una única trama de esta interfaz se encapsulan los cuatro canales que dirigirán el movimiento del dron.
  
  \item USB\_Depuración: Se trata del USB que conecta el módulo de adquisición de señales digitales de Logic, con el PC. Permite realizar los volcados de su memoria interna, para poder realizar posteriores tareas de depuración.
\end{itemize}


\subsection{Interfaces externos}
\label{subsec:GS_IE}

La estación de tierra se comunica con el resto del sistema mediante tres vías mostradas en la Figura~\ref{fig:NewSystArq}. Dos interfaces radio con el dron, uno de subida (\textit{Órdenes de movimiento}) y uno de bajada (\textit{Medidas de sensores}). Un interfaz USB para comandos de control (\textit{Instrucciones de mando}).\\
Paralelo a estos, existe un segundo interfaz USB desde la estación de tierra hacia el PC, utilizado exclusivamente para tareas de depuración (no presente en~\ref{fig:NewSystArq}). Este segundo USB, se comunica con la aplicación de análisis de señales digitales de Saleae, \textit{Logic} (\ref{sec:Logic}).



\subsection{Algoritmos de control sobre la FPGA}
\label{sec:Algoritmos de control sobre la FPGA}

La lógica construida en la FPGA se encarga de procesar información sobre la posición actual y la posición deseada para el vehículo, generando órdenes de movimiento que dirijan el dron hacia la posición deseada. Para ello la arquitectura software diseñada, se vale de tres puertos de comunicaciones (dos de entrada y uno de salida) y cuatro lineas de procesado paralelas (una para cada grado de libertad del vehículo). La relación entre estos elementos se muestra en la arquitectura de la Figura~\ref{fig:FPGA_New_arq}.\\
El conocimiento de la FPGA sobre la posición actual del vehículo, procede de las medidas de posición recibidas por radio desde el propio dron y la posición deseada, proviene del ordenador de mando. Ambos, interfaces internos de la estación de tierra (UART\_Sensores y UART\_Mando), se describen en el Apartado~\ref{subsec:GS_II}.\\

\begin{figure}[h]
	\centering
	\includegraphics[width=18cm, keepaspectratio]{Imagenes/FPGA_New_Soft_arq.png}
	\caption{Arquitectura del software programado en la FPGA}
	\label{fig:FPGA_New_arq}
\end{figure}

A continuación se describe superficialmente la lógica ejecutada dentro de la FPGA.
Las medidas de posición actual del dron, son recibidas por el módulo de \textit{SINCRONIA Y UART TRAMAS DRON}, el cual las entrega byte a byte al módulo \textit{DECODIFICADOR TRAMAS DRON}. Este se encarga de separar las medidas de altura, avance y desplazamiento lateral, entregándolas a los PIDs correspondientes. Estos tres PIDs requieren también de una consigna para funcionar, es decir, el valor que se desea conseguir en cada caso. Dichas consignas, serán la indicación de posición deseada para cada grado de libertad controlado en el vehículo. Estas vienen indicadas por el ordenador de mando, mediante tramas de mando, que viajan a través del módulo \textit{SINCRONIA Y UART TRAMAS PC}, hasta el \textit{DECODIFICADOR TRAMAS PC}. El decodificador, separa las consignas y se las comunica a cada módulo PID pertinente. Además, comunica a cada PID, sus parámetros Kp, Ki y Kd (también recibidos en la trama de mando). Así cada PID se configurará previo a la ejecución del control. Como último elemento incluido en las tramas de mando, esta el comando de giro, que es enviado al módulo \textit{ESCALADO}. Éste, ajusta el valor del comando de giro recibido, al rango dinámico esperado por el \textit{MODULADOR PPM}.\\
En este punto, los tres controladores PID disponen de lo necesario para realizar su tarea (parámetros, consignas y medidas). El resultado de su ejecución, genera las órdenes de movimiento, independientes para cada eje, que son recibidas por el \textit{MODULADOR PPM}, junto con el comando de giro ya escalado. El modulador, entrama las cuatro órdenes recibidas un una única trama y la modula mediante posición de pulso, enviándola hacia el transmisor (Módulo TX de la arquitectura \ref{subsec:GS_Desc}).\\
El ancho de banda del sistema, se determinar por el elemento más lento en realizar su tarea, dentro de la cadena completa del sistema. Siendo este las medidas de los sensores. Los módulos aquí descritos están diseñados para realizar su función rápidamente y quedarse a la espera por el siguiente conjunto de tramas entrantes. El cierre del bucle, desde la medida de los sensores, hasta la actuación sobre los motores, se realiza a una velocidad de 30.3 Hercios. Esto determina a su vez los tiempo de integración y derivación para los bucles PID, quedando estos en 33 mili segundos. Es resto de parámetros PID, son recibidos por puerto serie, como se ha comentado. Esta versatilidad en la configuración de los parámetros de control, permite al sistema tener un tipo de control concreto para cada fase del vuelo. Por ejemplo, los controladores no se comportarán igual durante el despegue, que durante el vuelo o aterrizaje.




\section{Ordenador de mando}
\label{sec: Ordenador de mando}

Se trata del PC de la Figura~\ref{fig:NewSystArq}. Dicho hardware se encarga de ejecutar el código python que dirigirá el vuelo del dron. La ejecución de dicho código, implica que el PC comunicará por USB, hacia la estación de tierra, las órdenes que deberá obedecer el vehículo controlado. Para el caso de este trabajo, el cuadricóptero de Syma.

\subsection{Objetivo}
\label{subsec:OM_Obj}

El objetivo de este módulo es permitir el control del vehículo desde PC, ofreciendo la menor cantidad de limitaciones posibles en cuanto a su manejo y configuración. Para ello, el módulo contará con las funciones comentadas a continuación.

\subsection{Funciones}
\label{subsec:OM_Func}

De manera general, el ordenador de mando cubrirá las siguientes dos funciones:
\begin{itemize}
  \item Ejecución de instrucciones en python.
  
  \item Comunicación hacia la estación de tierra a través de un puerto USB.
\end{itemize}

De manera más concreta, dichas funciones controlarán la estación de tierra y el vehículo. Para ello, las tramas transmitidas por USB incluirán información de dos elementos:
\begin{itemize}
  \item Controles sobre el vehículo: Información sobre el control de los cuatro grados de libertad del dron (cabeceo, alabeo, guiñada y altitud), con el objetivo de ofrecer el máximo nivel de manejo.
  
  \item Controles sobre la estación de tierra: Valores de los parámetros de configuración de los bucles de control PID, ejecutados en la estación. Esto permite su reconfiguración en tiempo de ejecución.
\end{itemize}


\subsection{Interfaz externo}
\label{subsec:OM_Int}

De manera funcional, este módulo hace uso únicamente de un interfaz con el sistema. El comentado \textit{Interfaz USB de Mando}, dirigido contra la estación de tierra y mostrado en la Figura~\ref{fig:NewSystArq}, el cual contiene las instrucciones de mando enviadas hacia la estación de tierra.\\
Como se comentó en el Apartado~\ref{subsec:GS_IE} aquí también existe un segundo interfaz USB, desde la estación de tierra hacia el PC, utilizado exclusivamente para tareas de depuración (no presente en~\ref{fig:NewSystArq}). Este segundo USB, comunica al PC con la herramienta de depuración \textit{Logic Analizer} (\ref{sec:Logic Analizer}) ubicada en la estación de tierra, cuyo uso se explica en el Apartado~\ref{subsubsec:GS_Mod5}.


\subsection{Librería Python}
\label{sec:Librería Python}

El software ejecutado en python en el ordenador de mando es el encargado de enviar las instrucciones de mando hacia la estación de tierra. Estas permiten modificar tanto los parámetros de los bucles PID, como sus consignas de posición, además de inicializar el enlace USB con la UART receptora en la FPGA.\\
A través de la ejecución de la función \textit{setPIDValues}, se cargan los valores de las constantes para los PIDs vertical (Atura) y horizontales (cabeceo y alabeo), junto al offset para la corrección del error de giro (guiñada).

\begin{flushleft}
\textit{def} setPIDValues(alt\_kp, alt\_ki, alt\_kd, xy\_kp, xy\_ki, xy\_kd, OffGiroDI):
\end{flushleft}

\begin{itemize}
  \item Los parámetros: alt\_kp, alt\_ki y alt\_kd, controlan las constantes, proporcional, integral y derivativa respectivamente, del bucle de control PID de altura.
  
  \item Los parámetros: xy\_kp, xy\_ki, xy\_kd, se aplican a las constantes, proporcional, integral y derivativa respectivamente, de ambos bucle de control PID horizontales.
  
  \item El parámetro OffGiroDI, es el encargado de permitir corregir el error, si lo hubiere, en el control del giro sobre sí mismo del dron.
\end{itemize}

Tras al menos una ejecución de esta función, se puede proceder a enviar instrucciones de mando al dron. Estas pueden enviarse de manera directa, a través de la instrucción setcontrols. Esta función permite dirigir el dron a una posición concreta en los tres ejecs controlados por posición, e indicarle una velocidad de giro constante, para el manejo de la guiñada. La función dispone de los siguientes parámetros:

\begin{flushleft}
\textit{def} setcontrols (ArrAb, DerIzq, DelDet, GiroDI, Duracion):
\end{flushleft}

\begin{itemize}
  \item Los parámetros: ArrAb, DerIzq y DelDet, son las consignas para los bucles de control PID en la FPGA. Estos son enviados a sus destinos, a través de los flujos de datos \textit{Comando de Altura}, \textit{Comando Desplazamiento Lateral} y \textit{Comando de Avance} de la Figura~\ref{fig:FPGA_New_arq}, respectivamente.
  
  \item El parámetro GiroDI, indica la velocidad de giro deseada para el vehículo. Es enviado directamente hacia el módulo de escalado de rango, de la arquitectura de la Figura~\ref{fig:FPGA_New_arq}.
  
  \item Duración, es el parámetro utilizado para especificar el tiempo de ejecución de cada instrucción, en segundos. Tras este periodo de tiempo se ejecutará la siguiente instrucción de mando.
\end{itemize}

Adicionalmente al método de control directo, se puede hacer uso de la función settrace, la cual genera posiciones intermedias entre la posición actual y la indicada en sus parámetros, para el instante de la ejecución.

\begin{flushleft}
\textit{def} settrace (ArrAb, DerIzq, DelDet, GiroDI, Duracion, Steps):
\end{flushleft}

Esta función hace uso de \textit{setcontrols},  para generar puntos intermedios en una trayectoria larga. Los parámetros son los mismos que para \textit{setcontrols}, salvo por el añadido de Steps, que indica el número de puntos intermedios a crear entre el punto actual y el destino indicado. Esta función es útil para recorrer distancias largas. Se debe a que en caso de, por ejemplo, despegue y vuelo a una distancia considerable del punto de despegue; se tendría un error de posición grande, lo que provoca un empuje considerable en la dirección de corrección del error. A pesar del posterior suavizado en la aceleración, debido a la componente derivativa, este empuje excesivo puede desestabilizar el control. Además al inclinar brusca y considerablemente el vehículo, se dificulta la adecuada medida de posición, por parte del sensor óptico. Ocurre algo similar con el sensor de altura. Para una inclinación considerable del vehículo, este mide una distancia mayor, debido al nuevo ángulo de incidencia sobre el suelo. Esto se traduce en un avance tortuoso del dron, como avanzando ``a tirones'' hacia su destino. Para evitar esto, se hace uso de \textit{settrace}, que disminuye el crecimiento excesivo de los errores, minimizando este efecto.\\


En este punto han quedado descritos los módulos que componen el sistema, sin entrar en detalle en los interfaces que los ponen en comunicación entre ellos.
A continuación se detallan los interfaces que conectan los cuatro módulos de nivel superior que toman partido en la arquitectura del sistema de la Figura~\ref{fig:NewSystArq}; \textit{Interfaz USB de Mando} e \textit{Interfaz Radio}. Cabe destacar que no existen interfaces que comuniquen de manera directa la electrónica propia del dron, con electrónica de sensores instalada para este TFG. Esto es debido a que se prefirió aislar dicha electrónica de la instalada originalmente en el dron, por problemas con la alimentación nativa (caídas de tensión abruptas durante aceleraciones). Además, no existe la necesidad específica de comunicar dichos módulos directamente (quedan indiréctamente comunicados entre sí a través de la información enviada a tierra, procesada por esta y recibida de vuelta en el dron). Dicha comunicación directa podría darse para arquitecturas de sistema diferentes, por ejemplo, aquellas propuestas más adelante en el apartado \ref{subsec:Mejoras en la arquitectura del sistema}.

\section{Interfaz USB de mando}
\label{sec: Interfaz USB de mando}

Para conseguir la programación de la trayectoria de vuelo del dron, desde un PC, es necesario comunicar este PC con el elemento encargado del control. En este caso, la FPGA de la estación de tierra. Esta interfaz comunica ambos elementos mediante tramas enviadas por puerto serie. Dichas tramas portan las instrucciones de posición que guiarán al vehículo, junto con los parámetros de configuración de los PIDs, utilizados por los algoritmos de control de la FPGA, según se indica en el Apartado~\ref{sec:Algoritmos de control sobre la FPGA}.
Estas tramas facilitan realizar múltiples ensayos de vuelo consecutivos, con mucha diferencia en el comportamiento de cada uno de ellos, facilitando a su vez corrección de errores y ajustes de parámetros.

\subsection{Características}
\label{subsec:Características}

Se trata de una comunicación unidireccional con origen en el ordenador de mando y destino en la estación de tierra. La comunicación se realiza por puerto serie, y se basa en el uso de los estándares USB 2.0, UART y RS232. Para la conversión del estándar eléctrico existente en el PC (USB) al utilizado por la FPGA (RS232), se hace uso de un driver de USB, diseño de FTDI Chip. El cual también convierte del protocolo de comunicaciones desde el PC al esperado en la FPGA (USB a UART). Concretamente es el canal B del integrado FT232HL el encargado de realizar dichas tareas, quedando el canal A reservado. Este se encuentra integrado en la misma placa de desarrollo que la FPGA (ICE40 UltraPlus Breakout Board~\ref{sec:ICE40 UltraPlus Breakout Board}).\\
El puerto de comunicaciones (USB a UART) se configura en tiempo de ejecución por la herramienta software ejecutada en el ordenador de mando (Apartado~\ref{sec:Librería Python}). En ella se indica el número del puerto, el cual depende de la asignación que realice el ordenador en uso y la velocidad de transferencia, fijada en 500Kbps.
Una vez abierto el puerto con esta configuración, se fragmentan las tramas y se envían byte a byte sin control de flujo, ni paridad. Se hace uso de diez bits por byte. Bit de inicio, 8 bits de datos y bit de parada.


\subsection{Formato de tramas}
\label{subsec:Formato de tramas}

Se hace uso de un formato de tramas fijas. La longitud es conocida y siempre la misma, 16 bytes. Y la posición de cada valor tampoco varía durante toda la ejecución, lo que facilita las tareas de decodificación y sincronía. A lo largo del trabajo, se han ido añadiendo o modificando campos de la información transmitida por este interfaz, según las necesidades puntuales de ensayos, o mejoras en el sistema.\\
Cada trama es enviada en el instante de ejecución de cada instrucción en el ordenador de mando. Cada instrucción se ejecuta durante un tiempo concreto, indicado al ejecutarla. De esta manera, cada trama aquí descrita será enviada, hacia la FPGA, tras el tiempo de ejecución de cada instrucción. En su versión final, las tramas componen sus 16 bytes con la construcción prefijada de las Tablas~\ref{fig:tramam1} y \ref{fig:tramam2}.


\begin{table}[h]
\footnotesize
\centering
\begin{tabular}{|l|l|l|l|l|l|l|l|l|}
\hline
\textbf{Field Name}     & STx1 & STx1 & Cmd\_ALT & Cmd\_L/R & Cmd\_F/B & Cmd\_T\_CW & PID\_Alt\_Kp & PID\_XY\_Kp \\ \hline
\textbf{Value}          & 0xFF & 0x5A & Variable & Variable & Variable & Variable   & Variable     & Variable    \\ \hline
\textbf{Length (Bytes)} & 1    & 1    & 1        & 1        & 1        & 1          & 1            & 1           \\ \hline
\textbf{Byte Position}  & 1    & 2    & 3        & 4        & 5        & 6          & 7            & 8           \\ \hline
\end{tabular}
\caption{Formato de tramas de mando, primera mitad}
\label{fig:tramam1}
\end{table}

\begin{table}[h]
\footnotesize
\centering
\begin{tabular}{|l|l|l|l|l|l|l|l|l|}
\hline
\textbf{Field Name}     & RSV & T\_CW\_Trimm & PID\_Alt\_Ki & PID\_Alt\_Kd & PID\_XY\_Ki & PID\_XY\_Kd & RSV & RSV \\ \hline
\textbf{Value}          & 0   & Variable     & Variable     & Variable     & Variable    & Variable    & 0   & 0   \\ \hline
\textbf{Length (Bytes)} & 1   & 1            & 1            & 1            & 1           & 1           & 1   & 1   \\ \hline
\textbf{Byte Position}  & 9   & 10           & 11           & 12           & 13          & 14          & 15  & 16  \\ \hline
\end{tabular}
\caption{Formato de tramas de mando, segunda mitad}
\label{fig:tramam2}
\end{table}

Se comienza la transmisión por el byte de la posición 1, terminando el envío con el byte 16. A continuación se describe cada campo de la trama:

\begin{itemize}
  \item Los dos primeros se usan de etapa de sincronía. Campos Stx1 y Stx2. Tienen los valores fijos 255 y 90 en base decimal. Siempre son transmitidos de esta manera. Así, el ordenador de mando, siempre comienza sus tramas con esta secuencia y la etapa receptora en la FPGA, espera por una secuencia de dos bytes consecutivos con valores 255 y 90 para sincronizar con la trama entrante. Tras esto, el receptor comenzará a decodificar los valores de los siguientes 14 bytes en el orden indicado para esta trama. De esta manera, el equipo receptor asociará cada valor con su campo correctamente. 
  
  \item Cmd\_ALT: Comando de altura. Representa el valor de la consigna de posición de altura deseada para el dron. Este valor, será posteriormente decodificado por la estación de tierra y enviado al bucle de control de altura como su consigna.
  
  \item Cmd\_L/R: Comando de desplazamiento lateral. Representa el valor de la consigna de posición lateral deseada para el vehículo. Este valor será decodificado por la estación de tierra y enviado al bucle de control de desplazamiento lateral, como su valor de consigna. Se trata del eje de libertad asociado al alabeo.
  
  \item  Cmd\_F/B: Comando de avance. Representa el valor de la consigna de posición frontal deseada para el dron. Este valor será decodificado por la estación de tierra y enviado al bucle de control de avance, como su valor de consigna. Se trata del eje de libertad asociado al cabeceo.
  
  \item Cmd\_T\_CW: Comando de giro en sentido horario. Representa el valor deseado de la velocidad de giro del dron, sobre sí mismo. Este valor será decodificado por la estación de tierra y enviado directamente al escalador, ya que este grado de libertad no se controla con un bucle cerrado. Se le deja su control exclusivamente a la electrónica propia del dron y su giróscopo interno. Se trata del eje de libertad asociado a la guiñada.
  
  \item PID\_Alt\_Kp: Parámetro de la constante proporcional de altura. Representa el valor deseado para la constante proporcional del bucle de control PID de altura. La diferencia  entre el valor de consigna de altura, Cmd\_ALT, y valor de altura medido por los sensores de a bordo, genera el valor de error de altura, componente del vector de error. Esta componente del error se multiplicará por el valor recibido en este campo para conseguir así la componente ``P'' del bucle de control de altura.
  
  \item  PID\_XY\_Kp: Parámetro de la constante proporcional de los ejes horizontales (desplazamiento lateral y avance). Representa el valor deseado para las constantes proporcionales de ambos bucles de control PID, avance y desplazamiento lateral. Ya que el dron es simétrico respecto de sus ejes de desplazamiento horizontal, se aplica la misma tensión a ambos bucles de control. La diferencia entre los valores de las consignas Cmd\_L/R y Cmd\_F/B y sus respectivas medidas por los sensores de posición de a bordo, generan los errores de posición horizontales. Estos errores se multiplicarán por el valor recibido en este campo, para conseguir así las componentes ``P'' de los bucles de control de los ejes horizontales: Avance y desplazamiento lateral.
  
  \item RSV: Los bytes de las posiciones 9, 15 y 16 están reservados para posibles usos futuros. Tienen valores constantes a cero.
  
  \item T\_CW\_Trimm: Parámetro de corrección de giro del dron sobre sí mismo. Representa el valor del offset a añadir al valor del comando ``Cmd\_T\_CW'' a enviar hacia el dron. El objetivo de este parámetro es corregir de manera constante el valor de la velocidad de giro sobré si mismo enviado hacia el dron. Ya que este valor se encuentra controlado por un bucle abierto en la electrónica de la estación de tierra, si la electrónica propia del dron tiene un error constante de giro, que no pueda corregir con su giróscopo, se aplicará la corrección necesaria a través del valor de este parámetro.
  
  \item  PID\_Alt\_Ki: Parámetro de la constante integral de altura. Representa el valor deseado para la constante integral del bucle de control PID de altura. El valor del error de altura comentado anteriormente, se integra y multiplica por el valor recibido en este campo de la trama. De esta manera se consigue la componente ``I'' del bucle de control de altura.
  
  \item PID\_Alt\_Kd: Parámetro de la constante derivativa de altura. Representa el valor deseado para la constante derivativa del bucle de control PID de altura. El error de altura comentado anteriormente, se derivará y multiplicará por el valor recibido en este campo de la trama. De esta manera se consigue la componente ``D'' del  bucle de control de altura. Este campo junto con los valores de los campos de las posiciones 7 y 11, completan los valores de los parámetros PID para el bucle de control de la altura. \textit{PID ALTURA} de la arquitectura mostrada en la Figura~\ref{fig:FPGA_New_arq}.
  
  \item PID\_XY\_Ki: Parámetro de la constante integral de los ejes horizontales. Representa el valor deseado para las constantes integrales de ambos bucles de control PID de posición horizontal. El control de posición del avance y el control de posición del desplazamiento lateral. Ya que el dron es simétrico respecto de sus ejes de desplazamiento horizontal, se aplica el mismo peso a las componentes integrales de ambos bucles de control. Los valores de los errores de posición horizontales comentados anteriormente, se integran y multiplican por el valor recibido en este campo, para conseguir así las componentes ``I'' de los bucles de control de los ejes horizontales: Avance y desplazamiento lateral.
  
  \item PID\_XY\_Kd: Parámetro de la constante derivativa de los ejes horizontales. Representa el valor deseado para las constantes derivativas de ambos bucles de control PID de posición horizontal. El control de posición del avance y el control de posición del desplazamiento lateral. Ya que el dron es simétrico respecto de sus ejes de desplazamiento horizontal, se aplica el mismo peso a las componentes derivativas de ambos bucles de control. Los valores de los errores de posición horizontales comentados anteriormente se derivarán y multiplicarán por el valor recibido en este campo, para conseguir así las componentes ``D'' de los bucles de control de los ejes horizontales: Frontal y latera. Este campo junto con los valores de los campos de las posiciones 8 y 13, completan los valores de los parámetros PID para los bucles de control del plano horizontal. \textit{PID AVANCE} y \textit{PID DESP. LATERAL} de la arquitectura mostrada en la Figura~\ref{fig:FPGA_New_arq}.
\end{itemize}



\section{Interfaz radio}
\label{sec: Interfaz radio}

Para ejecutar el control de vuelo del vehículo, mediante un PC, es necesario establecer comunicación con él desde tierra. Dicha comunicación se realiza exclusivamente por radio, mediante dos canales independientes como se muestra en la sección \textit{Módulo en Vuelo} de la Figura~\ref{fig:NewSystArq}.\\
La interfaz radio incluye ambos, el primero comunica la FPGA de la estación de tierra con los sensores instalados a bordo y el segundo con la electrónica propia del dron. Estos son los interfaces \textit{Medidas de sensores} y \textit{Órdenes de movimiento} respectivamente. Su objetivo es que la estación de tierra conozca la posición del dron y en base a esta, realice el control sobre el mismo. En su conjunto se trata de un enlace radio bidireccional entre la estación de tierra y el dron, con dos canales trabajando en la banda libre de 2.4GHz, separados en frecuencia. De esta manera se consigue un enlace bidireccional, full-duplex, mediante separación en frecuencia (FDM). Lo que permite transmisión simultanea de información de subida (órdenes) y bajada (medidas), sin colisiones. Existen otras opciones de multiplexación de canal, como radios basadas en separación temporal (TDM), código (CDM) o frecuencias ortogonales (OFDM). Cada una con sus dificultades, como bajada en tasa de transferencia, sincronización y sobre todo, complejidad de implementación. A continuación se explican ambos canales de comunicación entre la estación de tierra y el vehículo:


\subsection{Medidas de sensores}
\label{subsec:Downlink}

Esta interfaz, define el canal de enlace de bajada, es decir, la conexión radio unidireccional, con origen en el dron y destino en la estación de tierra. Se utiliza para comunicar las medidas de los sensores de posición tomadas a bordo del vehículo, con la FPGA en tierra, cuyos bucles de control, requieren de dicha información.
Esta información se compone de; una medida de distancia al suelo, o altura, tomada desde la parte media del dron, una medida del desplazamiento frontal, o avance, y una medida del desplazamiento lateral. Todas ellas se entregan en milímetros y referidas al punto de despegue.

\subsubsection{Características}
\label{subsubsec:Down_Car}

La separación en canales, entre subida y bajada, se configura durante la programación inicial de la radio. Este enlace ocupa el canal 102, asociado a una frecuencia concreta en la banda disponible por el transceptor NRF24L01. Se trata de una transmisión de baja potencia, con un alcance de unos 30 metros, transmitiendo a 1Mbps.

\subsubsection{Formato de trama}
\label{subsubsec:Down_FT}

Se hace uso de un formato de tramas fijas, como para el caso de las tramas de mando. En este caso la longitud de la trama es de seis bytes. Y la posición de cada valor tampoco varía durante toda la ejecución, siendo la que se muestra en la Figura~\ref{fig:down_frame}.
Cada trama es enviada en el instante posterior a la ejecución de las tres medidas de posición: altura, desplazamiento frontal y desplazamiento lateral.

\begin{table}[h]
%\footnotesize
\small
\centering
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Field Name}     & H\_Pos\_F/B & H\_Pos\_L/R & Alt      \\ \hline
\textbf{Value}          & Variable    & Variable    & Variable \\ \hline
\textbf{Length (Bytes)} & 2           & 2           & 2        \\ \hline
\textbf{Byte Position}  & 1           & 3           & 5        \\ \hline
\end{tabular}
\caption{Formato de tramas de bajada}
\label{fig:down_frame}
\end{table}


En estas tramas la sincronía está garantizada como parte del diseño de la transmisión realizada por la radio NRF24L01, por tanto no se hace uso de bytes de sincronía. Los seis bytes incluidos en la trama son tres campos con información útil, de dos bytes cada uno. Estos son:

\begin{itemize}
  \item H\_Pos\_F/B: Valor de la medida de avance. Representa los milímetros de desplazamiento frontal desde el origen de coordenadas definido anteriormente. Se almacena en 16 bits consecutivos, y se codifica en complemento a dos.
  
  \item H\_Pos\_L/R: Homólogo al campo ``H\_Pos\_F/B'', representando este caso los milímetros de desplazamiento lateral.
  
  \item Alt: Valor de la medida de altura. Representa los milímetros de desplazamiento vertical desde el estado ``aterrizado''. Se almacena en 16 bits consecutivos, y se codifica en binario plano, ya que no se contemplan alturas negativas para el marco de este TFG.
  
\end{itemize}

Con estas tres medidas, la estación de tierra puede ubicar de manera relativa el dron, generando así el vector de posición necesario para realizar posteriormente las correcciones de posición respecto de las órdenes comandadas.


\subsection{Órdenes de movimiento}
\label{subsec:Uplink}

Las órdenes de movimiento, con origen en el ordenador de mando y destino en el vehículo, componen el enlace de subida. Se trata de una conexión radio unidireccional, para compartir con el dron las instrucciones de movimiento que este deberá ejecutar. Además incluye canales auxiliares, de cuya función no se hará uso en este TFG.


\subsubsection{Características}
\label{subsubsec:Up_Car}

Se utiliza una radio NRF24L01 en la banda de 2.4GHz. Esta interfaz, empaqueta las órdenes proveniente de las tramas PPM, enviadas desde la FPGA a través de \textit{Tramas\_PPM} (Apartado~\ref{subsec:GS_II}), en una única trama radio. Dicha trama es entonces enviada hacia el modulo de recepción del dron.


\subsubsection{Formato de trama}
\label{subsubsec:Up_FT}

Este interfaz se compone de una transmisión de doce canales, de los cuales se hará uso exclusivamente de los cuatro primeros. Los ocho canales restantes portan comandos auxiliares; como la velocidad de reacción deseada para el dron, la cual se mantiene en su valor por defecto y dependiendo del modelo del dron utilizado, a veces disparan fotografías o vídeo de cámaras instaladas. El \textit{Transmisor radio de órdenes de movimiento} (Apartado~\ref{subsubsec:GS_Mod4}), se encarga de transmitir la información contenida en la trama de la Figura~\ref{fig:up_frame}, por radio, hasta la electrónica del dron.

\begin{table}[h]
\small
\centering
\begin{tabular}{|l|l|l|l|l|l|}
\hline
\textbf{Field Name}       & Cmd\_THR & Cmd\_R/L & Cmd\_F/B & Cmd\_T\_CW & Aux      \\ \hline
\textbf{Value}            & Variable & Variable & Variable & Variable   & Variable \\ \hline
\textbf{Length (ms)}      & 1 to 2   & 1 to 2   & 1 to 2   & 1 to 2     & 8 to 16  \\ \hline
\textbf{Channel Position} & 1        & 2        & 3        & 4          & 5 to 12  \\ \hline
\end{tabular}
\label{fig:up_frame}
\end{table}


El vehículo, entonces, realizará movimientos en base a los valores contenidos en dicha trama. Sus campos se comentan a continuación:

\begin{itemize}
  \item Cmd\_THR: Valor de velocidad de altura. Ocupa la primera posición en la trama. Representa el impulso deseado para el eje vertical del dron. Un valor de cero no tiene por qué implicar el apagado de los motores, depende de los valores de los siguientes dos canales.
  
  \item Cmd\_R/L: Valor de velocidad de desplazamiento lateral. Representa la velocidad de desplazamiento asociada al grado de libertad del alabeo.
  
  \item Cmd\_F/B: Valor de velocidad de avance. Representa la velocidad de desplazamiento frontal deseada para el dron. Está asociado al grado de libertad del cabeceo.
  
  \item Cmd\_T\_CW: Valor de velocidad de giro. Representa la velocidad de giro sobre sí mismo en el plano horizontal. Controla la guiñada del vehículo.
  
  \item Aux: Algunos de los ocho canales adicionales tienen valores fijos y otros variables, dependiendo de su funcionalidad y del dron utilizado. Para este trabajo, estos canales se mantendrán con su valor por defecto.
\end{itemize}





\chapter{Validación experimental}
\label{chap:Validación experimental}

\section{Eachine E010}
\label{sec:Eachine E010}

En principio se hizo uso del dron Eachine E010. Se trata de un pequeño cuadricóptero, ligero y de reacciones nerviosas. Cuenta con 8cm de ancho y 8 cm de largo, conductores en las aspas, para minimizar vórtices, batería de litio y 30 metros de alcance con su radio de 2.4GHz. Sobre él se hicieron pruebas de control en bucle abierto. Se realizaron las tareas de enlace de comunicaciones entre la estación de tierra y el dron y se probaron despegues con aterrizajes y vuelos cortos de ida y vuelta en línea recta.\\
El dron mostró buen control de vuelo en tiempo cortos, por tanto fue válido para pruebas de bucle abierto con algo de pre-énfasis. El dron, presentaba derivas erráticas en uno de sus ejes horizontales, y grandes derivas en el eje vertical, dependientes, entre otras cosas, del nivel de batería. Estas dificultades hicieron de los vuelos largos en bucle abierto, una tarea imposibles. Por tanto se intentó instalar el controlador de vuelo de bucle cerrado en dicho dron. Desgraciadamente el peso de la electrónica disponible era excesivo y hubo que abortar los intentos y buscar una plataforma de mayor potencia. Por este motivo se seleccionó el dron Syma X5C finalmente, frente al pequeño E010.


\section{Syma X5C en Bucle abierto}
\label{sec:Syma X5C en Bucle abierto}

Tras las pruebas con el E010, inicialmente se tuvo que conseguir el mismo control sobre el X5C. Para ellos se modificó el código de enlace con el dron, ejecutado en el módulo de uplink, para conseguir control básico sobre el X5C. Una vez enlazado se hicieron pruebas de control en bucle abierto de igual manera que con el E010. El dron Syma, resulto también difícil de controlar en bucle abierto para vuelos de más de 10 o 15 segundos. A parte de sus desvíos poco previsibles en cada eje, lo cual dificultaba ejecutar correcciones en base a ?trimado?, este dron presentaba una degradación considerablemente notable en la potencia de los motores a medida que se gastaba la batería. Posiblemente debido a la baja calidad de las baterías y de los controladores de los motores, junto a la inexistencia de reguladores de tensión, este problema dificultaba extremadamente su control en altura, haciéndolo casi imposible en bucle abierto. Se procedió por tanto rápidamente a instalarle el sistema de medida de posición. El X5C si era capaz de levantar la electrónica embarcada, pero sus motores quedaban encendidos casi al máximo de su potencia para mantener el vuelo. Esto continuaba dificultando el correcto control en altura, generando oscilaciones de una amplitud imposible de corregir para el PID de altura. En este punto, al menos existía un mínimo de control sobre el dron, con escasa estabilidad. Por tanto se procedió a aligerar la electrónica con cambios menores, y aligerar el dron, con modificaciones mayores. Básicamente se libró al dron de todo aquello estrictamente innecesario para el vuelo. Se acortaron cables, se eliminaron luces de indicación de frente, soporte de cámara, amarre de batería, topes de motores, protecciones de aspas, tornillos, y media estructura de plástico del dron. Algunos elementos retirados se sustituyeron por puntos de soldadura o pegamento, en pro de aligerar todo lo posible. Al retirar media estructura, la resultante pecaba de exceso de flexibilidad y falta de rigidez, lo que eliminó parte de la independencia de ejes, pero permitió a los controladores, ganar bastante en cuanto a estabilización del dron. En este punto el trabajo pendiente se centró en mejorar los parámetros PID de los controladores diseñados para el dron previo al cambio de peso, ya que los anteriores no eran correctos con el nuevo sistema. Además se trabajó rotando dos baterías y controlando rigurosamente su nivel de carga, ya que aunque los bucles de control PID corrigen parte de la disminución de potencia en los motores debido a la descarga de las baterías, llegado un nivel de carga bajo, los parámetros de control mismos, dejaban de ser igual de efectivos, y la velocidad de respuesta también disminuía, lo que al final se traducía en el mismo efecto, parámetros PID inadecuados. Procurando trabajar con baterías en un rango de carga concreto, se minimizo lo suficiente este efecto como para poder mejorar la estabilidad y control sobre el dron.


\section{Pruebas Unitarias}
\label{sec:Pruebas Unitarias}

En este apartado se describen las pruebas realizadas sobre los distintos módulos del sistema, previas a su integración.


\subsection{Pruebas del módulo de bajada}
\label{subsec:Pruebas en modulos de downlink}

Los softwares ejecutados en los módulos, downlink embarcado y downlink en la estación de tierra, se probaron inicialmente a través de sus interfaces de salida USB.\\
Para el código del módulo de downlink embarcado, se preparó la lectura de los sensores y la transmisión por radio de los datos leídos, simultáneamente al envío por USB de los mismos. de esta manera se pudo verificar visualmente que los sensores medían de manera adecuada a través del USB. En la Figura~\ref{fig:DownDroneCap} se muestra una captura con las medidas extraídas por USB de los sensores de embarcados.

\begin{figure}[h]
	\centering
	\includegraphics[width=14cm, keepaspectratio]{Imagenes/Drone_Sensors_Cap.png}
	\caption{Captura de medidas con sensores de a bordo}
	\label{fig:DownDroneCap}
\end{figure}

Para la comprobación del correcto funcionamiento del módulo receptor radio de medidas de posición, de la estación de tierra y su enlace radio con el trasmisor de bajada hacia FPGA, embarcado en el vehículo, se procedió a encender ambos módulos y realizar lecturas en el interfaz UART\_Sensores de la estación de tierra (Figura~\ref{fig:ETArq}), tal como se realizó para el módulo de downlink embarcado. Contrastando estas medidas con las de la Figura~\ref{fig:DownDroneCap} se pudo comprobar la correcta medida de los sensores, empaquetado, transmisión y recepción en tierra de dichas medidas.


\subsection{Pruebas del módulo de subida}
\label{subsec:Pruebas en modulo de uplink}

Este módulo se verificó a través de las pruebas de enlace con los distintos drones utilizados durante el desarrollo del TFG. Estas se realizaron en el punto de partida del proyecto, durante la creación del código de la tarea \textit{Enlace con el dron} del Apartado~\ref{sec:Plan de trabajo}. Durante el establecimiento del enlace entre el módulo de uplink y el dron, las luces de indicación de frente del dron cambian su patrón de parpadeo. En caso de un correcto enlace, dichas luces quedan fijas. Esta comprobación visual es suficiente para verificar el enlace, y de paso la correcta construcción y programación del módulo de uplink.


\subsection{Pruebas de módulos software}
\label{subsec:Pruebas de modulos software}

El módulo dos de la estación de tierra (Procesado y comunicaciones en~\ref{subsubsec:GS_Mod2}, mostrado en el apartado~\ref{subsec:GS_Desc}) ejecuta el software principal del sistema, compuesto de múltiples módulos diseñados en Verilog. Los módulos más sencillos se instanciaron tras la codificación, directamente sobre el sistema final. Los módulos restantes, debido a su complejidad o impacto en la seguridad del sistema, se verificaron de manera individual a través de simulaciones lógicas, previa su integración.

\subsubsection{Prueba de módulo decodificador de tramas de mando}
\label{subsubsec:Prueba de modulo decodificador de tramas desde PC}

El test consiste en enviar hacia el decodificador una trama completa para comprobar su correcta decodificación. Los valores incluidos en la trama van de 1 a 14 con valores crecientes. En la Figura~\ref{fig:FrameDecoderCap} se observa la trama enviada en la señal \textit{sink\_data} y su correcta decodificación junto a la señal de datos válidos asertada en el instante de recepción del último byte con valor 0x0E. El test solo captura en sus salidas los ocho primeros bytes ya que el módulo se diseñó originalmente para la recepción de tramas orientadas al control del dron en bucle abierto. Una vez comprobada la correcta decodificación de la trama, su funcionalidad de aumentó durante el desarrollo del trabajo para decodificar tramas completas, incluyendo los valores de los parámetros de los PIDs.

\begin{figure}[h]
	\centering
	\includegraphics[width=17cm, keepaspectratio]{Imagenes/Cap_Mod_frame_decoder_SP13PI1.png}
	\caption{Simulación funcional del módulo decodificador de tramas de mando}
	\label{fig:FrameDecoderCap}
\end{figure}

\subsubsection{Prueba de módulo decodificador de tramas desde drone}
\label{subsubsec:Prueba de modulo decodificador de tramas desde drone}

De manera similar al test ejecutado para el módulo decodificador de tramas desde PC, este módulo se ensayó bajo recepción de una trama completa y posterior comprobación de su decodificación. En este caso, las señales recibidas son valores enteros de dieciséis bits en complemento a dos, separados en grupos de dos bytes. Por tanto el ensayo envía un valor negativo (-2) como desplazamiento frontal, un valor positivo mayor que 255 como desplazamiento lateral (400) y un valor positivo menor que 255 como altura (31). El resultado de la decodificación se muestra en la Figura~\ref{fig:FrameDroneDecoderCap}, de manera síncrona al pulso en la señal \textit{source\_data\_valid} en las tres señales posteriores.

\begin{figure}[h]
	\centering
	\includegraphics[width=17cm, keepaspectratio]{Imagenes/Cap_Mod_frame_dron_decoder_SP18PI1.png}
	\caption{Simulación funcional del módulo decodificador de tramas de sensores}
	\label{fig:FrameDroneDecoderCap}
\end{figure}

\subsubsection{Prueba de módulo conversor de pulsaciones}
\label{subsubsec:Prueba de modulo conversor de pulsaciones}

Este módulo fue ensayado como parte de las pruebas previas al diseño de la arquitectura final para el TFG. Durante la fase de control de bucle abierto se hizo uso de un módulo en la FPGA que recibía la pulsación de ciertas teclas en el PC y las codificaba como parte del proceso de identificación de tecla pulsada. La secuencia enviada en la señal \textit{sink\_data} de la Figura~\ref{fig:KeyPressCap} simula las pulsaciones ``w'', ``a'', ``w'', ``s'', ``d'', caracter desconocido, shift izquierdo, espacio y ``b''. Dichas pulsaciones se codifican con distintos valores de 0 a 6. Ignorando la entrada de una pulsación en un carácter desconocido.

\begin{figure}[h]
	\centering
	\includegraphics[width=17cm, keepaspectratio]{Imagenes/Cap_Mod_KeyPress_SP6PI1.png}
	\caption{Simulación funcional del módulo de conversión de pulsaciones}
	\label{fig:KeyPressCap}
\end{figure}

\subsubsection{Prueba de módulos PID}
\label{subsubsec:Prueba de modulos PID}

Los módulos PID que controlan altura y desplazamientos frontal y lateral hacen uso de una lógica similar, salvando diferencias menores como el truncamiento de valores negativos para el caso del PID de altura y el ajuste de salida a los rangos esperados para la generación de las señales PPM. Los ensayos se realizaron en cuatro escenarios distintos, para comprobar el correcto funcionamiento de las distintas componentes:

\begin{itemize}
  \item TEST\_1: Ensaya la componente proporcional en sentido negativo. El resultado del bucle en negativo se observa en la señal \textit{pid\_prereg} de la Figura~\ref{fig:PIDAltCap}. Dicho valor es capado posteriormente a cero en el registro de salida del módulo PID \textit{source\_pid}.
  
  \item TEST\_2.1: Ensaya la componente integral en sentido positivo. Su crecimiento se observa sobre el registro \textit{error\_i\_acumm} con suma resultante sobre \textit{source\_pid}.
  
  \item TEST\_2.2: Tiene por objetivo ensayar el comportamiento del módulo para el caso de la puesta a cero de los parámetros que rigen el PID. Se desea conservar el valor integral, sin aplicar sobre el módulo correcciones adicionales o puestas a ceros inadecuadas.
  
  \item TEST\_3.1: En este caso de ensayo se pone a prueba la componente derivativa. Para ello se genera un error en sentido negativo y se observa el impacto de la derivada sobre la señal \textit{source\_pid} de la Figura~\ref{fig:PIDAltCap}.
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[width=18cm, keepaspectratio]{Imagenes/Cap_Mod_pid_altitude_SP19PI6.png}
	\caption{Simulación funcional del módulo PID de altura}
	\label{fig:PIDAltCap}
\end{figure}

\subsubsection{Prueba de módulo de comunicaciones UART}
\label{subsubsec:Prueba de modulo de comunicaciones UART}

El objetivo de este ensayo es comprobar que el módulo UART, responde al baud rate programdo y que la decodificación del byte entrante se realiza en el orden adecuado, a efectos de bit más y menos significativos. Se inyecta un cero, seguido de un uno a través de la señal \textit{sdin}, en orden de bit menos significativo primero. El resultado se puede observar en la señal data, síncrona con la señal data\_rdy de la Figura~\ref{fig:UARTCap}, sin errores de trama para ninguno de los dos casos ensayados.

\begin{figure}[h]
	\centering
	\includegraphics[width=18cm, keepaspectratio]{Imagenes/Cap_Mod_uart_rx_SP8PI1.png}
	\caption{Simulación funcional del módulo UART}
	\label{fig:UARTCap}
\end{figure}


\subsubsection{Prueba de módulo de modulación PPM}
\label{subsubsec:Prueba de modulo de modulación PPM}

Este ensayo permite verificar las correctas transiciones entre los estados de cada canal y entre los 12 canales. En la Figura~\ref{fig:PPMCap} se observa el registro \textit{PPM\_STATE}, que almacena el estado encargado de contabilizar el tiempo a cero de cada pulso de bajada. Por otro lado el estado \textit{CHOOSE\_CHANNEL} se encarga de gestionar las transiciones para cada canal.

\begin{figure}[h]
	\centering
	\includegraphics[width=18cm, keepaspectratio]{Imagenes/Cap_Mod_ppm_encoder_SP10PI1.png}
	\caption{Simulación funcional del módulo PPM}
	\label{fig:PPMCap}
\end{figure}

Este ensayo permitió corregir errores en las transiciones entre estados, que producían saltos inadecuados.


\section{Condiciones de los bucles de control}
\label{sec:Condiciones de los bucles de control}

Desde un punto de vista alejado de los parámetros PID de los bucles de control, existen algunos factores importantes que limitan los resultados obtenibles con una arquitectura concreta. Para el caso de este trabajo, la arquitectura elegida permitió usar tarjetas de desarrollo en vez de hardware propietario, ahorrando tiempo de desarrollo y costes. Pero a su vez implicó ciertas limitaciones en el ancho de banda final del sistema y sobre todo en las latencias. Ambos dos tienen relación directa con el resultado de la calidad del control final.

\subsection{Ancho de banda}
\label{subsec:Ancho de banda}

El ancho de banda se vio limitado por las velocidades de ejecución más lentas dentro del sistema, estas son la velocidad de recepción de tramas de la electrónica propia del dron, la cual limita cuantas órdenes puede atender por segundo, y la lectura de los sensores, limitada por la electrónica embarcada y las especificaciones de los propios sensores. Finalmente se estableció una velocidad de lectura de 30.3 hercios, que permitía a los sensores ser leídos adecuadamente, y a la electrónica propia del dron, atender todas las tramas entrantes. Esto limita la brusquedad de las reacciones del dron, en caso de correcciones necesarias, y la suavidad del mismo durante su vuelo.

\subsection{Retardo}
\label{subsec:Retardo}

Aunque el ancho de banda es un parámetro fundamental en el control de un sistema, para el caso de este TFG, la mayor cantidad de problemas durante el desarrollo y pruebas del sistema, fueron originados por falta de estabilidad. Esta se pone en riesgo por múltiples factores, algunos ya comentados, pero principalmente por los retardos en la ejecución de los bucles de control. El tiempo que transcurre desde que se realiza la medida de posición de un eje, hasta que se actúa en consecuencia para corregir el error, es fundamental para estabilizar correctamente el vehículo.\\
En este aspecto, hay varias fuentes de retardo en el sistema, algunas inherentes a algún componente, como los retardos de medida de los sensores, y otras, fruto de la arquitectura escogida. Por ejemplo el hecho de que el proceso de control sea ejecutado en tierra y no a bordo del dron, genera retardos asociados a la transmisión de los valores. Las medidas no son procesadas a bordo sino que se transmiten hacia tierra, donde se procesan para obtener una respuesta, y dicha respuesta se devuelve al dron. Este proceso de transmisión a tierra añade retardos indeseados, pero necesarios para el funcionamiento del sistema.\\
Si tratamos de contabilizar a groso modo los retardos existentes, tenemos:

\begin{itemize}
  \item 30ms del sensor de medida de altura, ToF.
  
  \item Retardo máximo añadido por la sincronía entre la trama PPM  enviada desde la FPGA, y la lectura realizada por la electrónica de uplink, 33ms.
  
  \item Enlaces radio, no más de 120uS sin contar preámbulos.
  
  \item Tres comunicaciones SPI, unos 144us.
  
  \item Dos transmisiones UART de no más de 240uS.
\end{itemize}

A falta de contabilizar de manera más fina los retardos, es sabido que existe un mínimo de 63.5ms de retardo entre medida de la posición y reacción. Esto, sin ser una cifra catastrófica, si es cierto que implica ciertas limitaciones a la hora de conseguir una suavidad de vuelo concreta.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Conclusiones %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage % empezamos en página impar
\chapter{Conclusiones}
\label{chap:Conclusiones}

Para terminar, realizaremos un repaso de los objetivos alcanzados, los métodos y las dificultades encontradas en el proceso. Gracias a ellas se ha sufrido y aprendido durante todo el proyecto. A cada elemento diseñado, se han encontrado formas mejores de hacerlo en un futuro, alternativas con propiedades distintas y opciones a elementos sueltos o la propia arquitectura misma, que podrían dar resultados diferentes y mejores. Finalmente se ha conseguido un resultado satisfactorio con el objetivo principal que se tenía, estabilizar y controlar un dron de bajo coste desde un ordenador. El trabajo podría dividirse en dos grandes bloques, control del dron mediante bucles abiertos y control mediante bucles cerrados.

\begin{itemize}
  \item Control mediante bucles abiertos: Esta fue la primera aproximación a tener un control mínimo de los vehículos desde el ordenador. El resultado fue positivo desde el punto de vista de lo que este tipo de sistemas pueden llegar a ofrecer. Se diseñó software y hardware completamente funcional, permitiendo el enlace con el dron y su obediencia ante las instrucciones dadas desde el pc. Pero las derivas propias de los drones, especialmente notables en drones de bajo coste, dificultaron excesivamente un buen control del mismo mediante esta metodología. Los resultados conseguidos permitían controlar un dron, comandándole instrucciones que este obedecía, pero dicho control era precario, falto de precisión y repetitividad. Para un ejercicio de despegue y parada en vuelo, llegaba un momento en que dichas derivas dirigían el dron contra el suelo, contra una pared, etc. La problemática de este método era difícil de subsanar con la infraestructura disponible, por este motivo se procedió a evolucionar todo el sistema, hardware y software, tanto en tierra como a bordo, dotándolo de una nueva dimensión, conocimiento en el dron de la propia ubicación relativa del dron. Esto supuso poder avanzar al siguiente tipo de control.
  
  \item  Control mediante bucles cerrados: Esta fue la arquitectura definitiva diseñada para el control del dron. Se diseñó electrónica y software para permitir al dron medir su propia ubicación respecto del punto de despegue y transmitirla al sistema en tierra. La estación de tierra recibió añadidos hardware, y una completa actualización de software para recibir, procesar y corregir la ubicación del dron mediante PIDs, enlaces serie y radio, satisfactoriamente. El sistema en este punto permitió recibir instrucciones de posición desde el ordenador y controlar el dron para obedecerlas. Mediante estos cambios se consiguieron vuelos significativamente más estables y similares entre sí. Los cambios permitieron además ampliar la duración de los vuelos hasta los límites impuestos por los niveles de carga en las baterías, lo que facilitó las tareas de ajuste de parámetros PID y experimentación.
\end{itemize}

El trabajo realizado pone a disposición pública el hardware, software y diseño del sistema, listos para que cualquiera persona pueda adquirir los elementos por un bajo coste, instalarlos y ponerlos en funcionamiento. Esto ofrece un gran abanico de posibles modificaciones, mejoras y desarrollos futuros.

\section{Trabajo futuro}
\label{sec:Trabajo futuro}

El sistema desarrollado ofrece muchas posibilidades de mejoras y añadidos. En este apartado se pretenden repasar algunos de los más interesantes.

\subsection{Mejoras en la arquitectura del sistema}
\label{subsec:Mejoras en la arquitectura del sistema}

\begin{itemize}
  \item La arquitectura del sistema es posiblemente la consideración de diseño cuyo cambio tenga un mayor impacto en el resultado final. La premisa de procesar con la FPGA en tierra, tiene ventajas y desventajas. Probablemente la peor contrapartida sea los tiempos de transmisión y recepción añadidos por los distintos módulos que intervienen en la comunicación de las medidas hacia tierra y las órdenes de vuelta hacia el dron. Estos retardos añadidos, empeoran la estabilidad que se puede llegar a conseguir, con el vehículo en vuelo. El cambio más significativo pasaría posiblemente por trasladar la FPGA a la electrónica embarcada, con conexión directa a los sensores y a los drivers de los motores. Esto supondría incluir una cantidad considerable de software en la FPGA, a cambio de disminuir los retardos a más de la mitad, ganando en favor de la calidad del control que se ejerce sobre el dron.
\end{itemize}

\subsection{Mejoras hardware}
\label{subsec:Mejoras hardware}

\begin{itemize}
  \item Diseñar una única tarjeta para el sistema embarcado es una mejora que aportaría ventajas tanto con la arquitectura del sistema actual, como en caso de llevar la FPGA a bordo. En ambos casos, la disminución de peso y las mejoras en la fijación de la electrónica, favorecerían que hubiese menos interacción entre ejes (debido al error de colocación de los sensores de flujo y de altura) y que la potencia entregada por los motores fuese más holgada, mejorando la estabilidad y ahorrando batería.
  
  \item A parte de cambios sobre el sistema, se pueden plantear añadidos de interés para el sistema final, como podrían ser un conjunto de magnetómetros de 2 ejes (ubicados de manera horizontal) para medir el error de giro, lo que permitiría corregirlo, a la vez de ganar un parámetros de orientación global. También se podría incluir una cámara dependiendo del peso liberado al rediseñar la electrónica, lo cual mezcla bien con proyectos que hacen uso de ubicación local en base a reconocimiento de etiquetas por imagen. Ambas mejoras ofrecerían más capacidad de vuelo autónomo, a través de un mejor conocimiento sobre la ubicación del vehículo.
\end{itemize}

\subsection{Mejoras software}
\label{subsec:Mejoras software}

\begin{itemize}
  \item Respecto del diseño software, es difícil no encontrar maneras mejores, más eficientes de construir código igualmente funcional, una vez terminado cada módulo. Invertir tiempo en parámetros PID más ajustados, mejoras en el software existente, compactarlo, ejecutando el máximo posible sobre la FPGA (eliminando la necesidad de procesadores periféricos) y cambios de esta índole, podrían reducir los retardos de cierre de los bucles, ganando en estabilidad.
  
  \item Ampliar la librería en python es una mejora que iría en pro de la facilidad de uso. Permitiría la repetición de ensayos con menos esfuerzo.
  
  \item Los controladores actuales realizan su tarea en base exclusivamente a la posición del vehículo, pero no reparan en limitaciones de velocidad o aceleración. Una mejora potente sería ubicar bucles de control de velocidad y aceleración bajo los actuales bucles de control de posición. Esto controlaría las brusquedades y dotaría al sistema de un mayor control sobre cómo se desplaza el vehículo.
  
  \item Generador de trayectorias: Para poder acometer un generador de trayectorias completo, serían necesarias modificaciones hardware y software en la estación de tierra. Estas deberían permitir a la estación de tierra informar al ordenador de mando de la ubicación actual del dron (obtenida de las medidas de los sensores embarcados). Con este añadido se permitiría al software en el pc crear verdaderos puntos intermedios en el avance de dron, dependientes tanto de la posición actual, como de la posición de destino, trazando así una trayectoria sin incrementos exagerados en el error de los bucles de control.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BIBLIOGRAFIA %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage

\textbf{{\Large Bibliografía}}



% https://www.parrot.com/soluciones-business/profesional/parrot-sequoia
% http://www.centum-rt.com/en/lifeseeker/
% http://www.ingenieros.es/noticias/ver/life-seeker-sistema-para-la-localizaciandoacuten-de-personas-desde-el-aire/2735
% https://www.bbc.com/news/technology-38450664
% https://www.digikey.com/en/articles/techzone/2012/jul/a-designers-guide-to-mems-sensors
% https://charlestytler.com/quadcopter-equations-motion/
% https://www.infineon.com/dgdl/Infineon-Application-Motor_Control-Drone_Electronic_Speed_Controller_ESC-TR-v01_00-EN.pdf?fileId=5546d462580663ef015843a229fe54ea
% http://fpvmax.com/2017/08/09/pids-ajuste-drones/
% https://www.arrow.com/es-mx/research-and-events/articles/fpgas-in-neural-networks
% https://core.ac.uk/download/pdf/154797518.pdf
% https://www.luisllamas.es/arduino-spi/
% https://www.solitontech.com/uart-protocol-validation-service/
% https://www.st.com/en/imaging-and-photonics-solutions/vl53l0x.html
% https://www.bitcraze.io/flow-breakout/
% https://www.pixart.com/products-detail/44/PMW3901MB-TXQT
% https://hipertextual.com/presentado-por/vodafone-one/paola-santana
% https://www.amazon.com/Amazon-Prime-Air/b?ie=UTF8&node=8037720011
% http://www.automatas.org/hardware/teoria_pid.htm
% https://teslabem.com/nivel-intermedio/fundamentos-del-protocolo-i2c-aprende/
% https://teslabem.com/nivel-intermedio/fundamentos-del-protocolo-i2c-aprende/

%\begin{verbatim}
%\end{verbatim}



\cleardoublepage

% Las siguientes dos instrucciones es todo lo que necesitas
% para incluir las citas en la memoria
\bibliographystyle{abbrv}
%\bibliographystyle{apalike}
\bibliography{memoria}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ANEXOS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage

\appendix
\chapter{Mecanismos de comunicación}
\label{app:MecCom}


A lo largo de este trabajo, se hace uso de diferentes estándares y protocolos de comunicación para enlazar distintos módulos, permitiéndoles comunicarse entre ellos de una manera determinada. Aquí se comentan algunos de los mecanismos empleados en el informe.

\section{UART}
\label{sec:UART}

Se trata de un sistema de comunicaciones serie asíncronas (Universal Asynchronous Receiver Transmitter) capaz de realizar una comunicación full dúplex bidireccional con tan solo dos hilos, transmisión y recepción (más un tercero, a modo de referencia, si los dispositivos en comunicación no gozasen de una referencia común de tensión). Se utiliza cada hilo exclusivamente para cada sentido de la comunicación.\\
En el sistema se utilizan comunicaciones asíncronas en dos ubicaciones distintas. En la Figura~\ref{fig:uartframe} se muestra la transmisión de un byte que incluye bit de paridad \cite{uart_adv}. En el trabajo realizado, este bit no está en uso, el resto de la configuración es idéntica a la utilizada. Se comienza con el bus a nivel alto. El primer flanco de bajada marca la llegada del bit de inicio de paquete, ``START''. Seguido de los ocho bits de datos comenzando por el bit de menor peso ``D0'', y acabando con un último bit de parada ``STOP'', este indica el final del paquete. La línea roja del cronograma de la Figura~\ref{fig:uartframe}, muestra el instante de detección del bit de inicio, y  los posteriores instantes de muestreo de cada bit. Los bits se reciben a la tasa de transferencia preestablecida de 500Kbps, en caso contrario, se perdería la sincronía con el byte en transmisión, pudiendo perder, o recibir prematuramente el bit de parada (dependiendo de si el error en la tasa de transferencia es por exceso o por defecto), produciéndose un error de ``framing''. En caso de transferirse adecuadamente, el valor del byte estaría disponible al recibir el último bit transmitido, ``D7''.

\begin{figure}[h]
	\centering
	\includegraphics[width=14cm]{Imagenes/UART_funcionamiento.png}
	%\includegraphics[width=12cm, keepaspectratio]{Imagenes/Yaw-pitch-roll-Quadcopter.png}
	\caption{Formato de paquete UART}
	\label{fig:uartframe}
\end{figure}

\section{SPI}
\label{sec:SPI}

A lo largo del TFG se hace uso de puertos serie, SPI, en tres ubicaciones distintas, dos en la estación de tierra y la tercera en la electrónica embarcada.\\
Un puerto SPI se trata de una comunicación maestro esclavo. Esta se basa en una comunicación serie, síncrona de tres o cuatro hilos para un enlace bidireccional, con un único dispositivo cada vez \cite{spi_adv}. En la Figura~\ref{fig:spiframe} se muestra un ejemplo de comunicación, y en la Figura~\ref{fig:spiarq} un ejemplo de las conexiones. La única señal opcional es la selección del esclavo, Slave Select (SS). Las tres señales obligatorias son el reloj (SCLK), la salida de datos del maestro y entrada hacia el esclavo (MOSI) y la entrada de datos del maestro y salida del esclavo (MISO).

\begin{figure}[h]
	\centering
	\includegraphics[width=14cm]{Imagenes/spi_funcionamiento.jpg}
	\caption{Funcionamiento de una comunicación SPI}
	\label{fig:spiframe}
\end{figure}

\begin{itemize}
  \item SS: En caso de tener conexión a múltiples dispositivos, el maestro puede escoger con cual entablar comunicación, asertando este pin, activo a nivel bajo, en el esclavo deseado.
  
  \item SCLK: Se trata de la señal de reloj. Se utiliza para sincronizar las transmisiones. En el flanco de bajada se deben ubicar los datos en la salida correspondiente, y se deben leer en el flanco de subida.
  
  \item MISO: Master Input Slave Output. Convención utilizada para designar el pin de entrada de datos hacia el maestro, desde los posibles esclavos.
  
  \item MOSI: Master Output Slave Input. Ofrece la funcionalidad complementaria al pin MISO. En este caso, es el maestro el que utiliza este pin de salida y los esclavos como entrada.
  
\end{itemize}

Un esquema típico de conexión con múltiples esclavos se muestra en la Figura~\ref{fig:spiarq}. Para este trabajo, se hará uso de comunicaciones con un único esclavo únicamente, ya que se dispone de tres radios NRF24L01 y tres procesadores de Atmel independientes.

\begin{figure}[h]
	\centering
	\includegraphics[width=14cm]{Imagenes/spi_esquema.png}
	\caption{Esquema de conexión para un puerto SPI}
	\label{fig:spiarq}
\end{figure}

\section{I2C}
\label{sec:I2C}

Se trata de un desarrollo de Philips para la conexión de múltiples circuitos integrados de semejante o distinta naturaleza, sobre un bus común.\\
De manera similar al estándar de SPI, I2C hace uso de una arquitectura maestro-esclavo, síncrona, bidireccional, en este caso half-dúplex, mediante dos hilos: Reloj (normalmente designado SCL o CLK) y datos (SDA) \cite{i2c_adv} que se conectan a todos los dispositivos colgados del bus, como se muestra en la Figura~\ref{fig:i2carq}.

\begin{figure}[h]
	\centering
	\includegraphics[width=10cm]{Imagenes/I2C_Arq.png}
	\caption{Arquitectura hardware de un bus I2C}
	\label{fig:i2carq}
\end{figure}

Las líneas de reloj y datos se encuentran, por defecto, a nivel alto gracias a dos resistencias de ``pull-up'', Rp en la arquitectura arriba indicada. Para iniciar una comunicación, dichas líneas deben ser comprobadas a fin de evitar colisiones. Si el bus I2C se encuentra libre en ese instante, se puede iniciar una comunicación manteniendo la línea SCL a nivel alto y forzando un flanco de bajada en la línea de datos SDA. Este evento fuerza a los esclavos a atender el siguiente mensaje recibido, por si fuera destinado a ellos. La trama tiene el formato especificado en la Figura~\ref{fig:i2cmsg}. El destinatario se especifica en la trama enviada a través del primer grupo de 7 a 10 bits, dependiendo del dispositivo, seguido del bit que especifica el sentido de la información; se desea enviar información hacia el esclavo, o se quiere solicitar información de él. Tras cada grupo de datos transferidos, se envía un ACK o un NoACK al remitente, para informarle si el paquete ha sido recibido con éxito. La trama se termina con el envío de un bit de parada, señalado por un flanco de subida en la señal SDA, mientras se mantiene la línea SCL a nivel alto.

\begin{figure}[h]
	\centering
	\includegraphics[width=14cm]{Imagenes/I2C_Frame_Format.jpg}
	\caption{Formato de trama I2C}
	\label{fig:i2cmsg}
\end{figure}

\section{PPM}
\label{sec:PPM}

Las siglas PPM vienen de Pulse Position Modulation. Se trata de una modulación en la que cada canal tiene un instante de llegada concreto, manteniendo constantes la amplitud de los mismos \cite{PPM_adv}, respecto del canal inmediatamente anterior. El desfase que se produzca respecto de dicho instante se transforma en el valor que se asigna a ese canal. De esta manera pueden codificarse todos los canales utilizados sobre un único conductor mediante multiplexación en tiempo. El aspecto general de una trama se muestra en la Figura~\ref{fig:ppmframe}. En ella se tiene seleccionado el canal 1 para mostrar su temporización.\\
Una trama completa PPM para el dron SYMA-X5C utilizado (las características básicas de PPM se mantienen entre distintos fabricantes, pero particularidades como el número y orden de los canales puede variar) se compone de doce canales. El inicio de trama se marca con un pulso a nivel bajo de 0.3 milisegundos. A partir de este instante se comienza el conteo de cada canal, indicado por los niveles altos y separados entre ellos a por pulsos de bajada de 0.3ms. La trama termina con un último pulso de bajada de 0.3ms que indica el fin de trama. Cada canal tiene una duración mínima asignada de 1ms y una duración máxima de 2ms contando con su flanco de 0.3ms de bajada. Estos tiempos, sumados al pulso de inicio de trama, completan la duración de una trama con un máximo de 24.3ms. Cada canal por tanto tendrá su valor mínimo para una duración a nivel alto de 0.7ms (canal 1 de la Figura~\ref{fig:ppmframe}) y su valor máximo para 1.7ms.

\begin{figure}[h]
	\centering
	\includegraphics[width=14cm]{Imagenes/Mod_PPM.png}
	\caption{Señal PPM hacia el módulo de transmisión de uplink}
	\label{fig:ppmframe}
\end{figure}

En este TFG se hace uso de esta técnica, dado que el módulo que maneja esta interfaz estaba originalmente diseñado para recibir la modulación PPM de un mando de radio control. PPM es la modulación más extendida en la mayoría de mandos de radio control para conectarse a módulos externos de bandas, potencias y otras características distintas a las suyas nativas, por tanto resulta cómodo adaptarse a esta modulación, para comunicarse con el módulo de uplink.


\chapter{Sistemas de control}
\label{app:Sistemas de control}


Los sistemas de control de un dron se basan principalmente en bucles de control PID \cite{PIDs}, ejecutados por la electrónica de control antes mencionada. Estos sistemas son la herramienta principal para garantizar la estabilidad de vehículo. Los sistemas de control ejecutados dirigen la corriente en cada motor para mantener el sistema estable. Además de los sistemas comunes a todo dron, este TFG hace uso de sus propios bucles de control para conseguir su objetivo. Estos bucles, trabajan de manera simultánea y paralela a los propios del dron. A efectos del trabajo realizado, los bucles de control implementados en este TFG se consideraran los de mayor nivel, ya que son los encargados de comandar a los intrínsecos del dron, considerados de bajo nivel.\\
Los sistemas de control usados en este TFG son de dos tipos, bucle abierto y bucle cerrado, cada uno utilizado de una manera concreta en distintas partes del sistema.


\section{Bucle abierto}
\label{sec:Bucle abierto}

Los bucles abiertos reciben una señal y producen una respuesta concreta resultado de convolucionar la entrada, con la función de transferencia del bucle. Pueden ser lineales e invariantes en el tiempo, o no, dependiendo de la necesidad concreta que deban cubrir. Su respuesta es enviada hacia los actuadores, o bucles de siguiente nivel como se muestra en la Figura~\ref{fig:OpenLoop}. La respuesta del controlador de bucle abierto es independiente de la situación del dron, respuestas de sensores, posición, ubicación y demás. Por tanto, asumiendo el caso de un bucle de control abierto invariante y sin memoria, si se ejecuta en dos ocasiones con la misma señal de entrada, producirá dos veces la misma señal de salida.

\begin{figure}[h]
	\centering
	\includegraphics[width=16cm, keepaspectratio]{Imagenes/Open_loop_Controller.png}
	%\includegraphics[width=12cm, keepaspectratio]{Imagenes/Yaw-pitch-roll-Quadcopter.png}
	\caption{Esquema básico de un sistema de control de bucle abierto}
	\label{fig:OpenLoop}
\end{figure}

En relación al trabajo realizado, este tipo de bucle se usa por ejemplo en el control de la guiñada, en la cual, es un bucle cerrado de bajo nivel el que se encarga de girar lo indicado por el bucle abierto de nivel superior programado en la FPGA de control.

El comportamiento de este tipo de bucles difiere de los bucles cerrados mencionados en el siguiente punto.


\section{Bucle cerrado}
\label{sec:Bucle cerrado}

Los bucles cerrados hacen uso de dos señales de entrada. Una de ellas es el comando, es la señal que indica el objetivo a alcanzar en algún parámetro concreto por el bucle. Otra es la señal recibida de alguna otra parte del sistema o sensor, capaz de medir e informar sobre el estado del parámetro objetivo. Ambas señales se restan y producen una señal de error que es entregada al controlador \cite{closed_loop_pid}, como se muestra en la Figura~\ref{fig:ClosedLoop}. Este opera de la misma manera que para el bucle abierto, generando una respuesta que es entregada a otro módulo, ya sea un bloque de menor nivel o un actuador.

\begin{figure}[h]
	\centering
	\includegraphics[width=16cm, keepaspectratio]{Imagenes/Closed_Loop_Controller.png}
	%\includegraphics[width=12cm, keepaspectratio]{Imagenes/Yaw-pitch-roll-Quadcopter.png}
	\caption{Esquema básico de un sistema de control de bucle cerrado}
	\label{fig:ClosedLoop}
\end{figure}

Estos bucles de control si tienen en cuenta el estado actual del parámetro objetivo para realizar su corrección. Al realizar una medición sobre el mismo, pueden acomodar la respuesta del controlador a valores ajustados a la situación actual del parámetro a modificar. Pudiendo darse el caso, de que para una entrada distinta de cero, la salida del sistema hacia los actuadores, sea cero. Este sería el caso en el que el valor comandado en la entrada, es igual que el valor medido por el sensor, generando por tanto una señal de error cero (asumiendo por ejemplo una respuesta proporcional del controlador).


\section{Algoritmos de control PID}
\label{sec:Algoritmos de control PID}

Este TFG hace uso de controladores PID. Ejecuta esta clase de sistema de control a través de algoritmos que calculan el error como la diferencia entre una señal de comando (instrucción de mando desde PC) y una señal entrante (medida de un sensor). Dicho error (e(t) en la Figura~\ref{fig:PID_Controller}) entonces pasa por tres procesos paralelos.

\begin{itemize}
  \item Un proceso de proporción: Su multiplica el error por una constante proporcional según la ecuación~\ref{eq:P}. El objetivo es aproximar el error a cero a través de actuar sobre el sistema, de manera proporcional al error existente en cada evaluación del bucle.
	\begin{equation}
		P[n] = Kp \cdot e[n]
	\label{eq:P}
	\end{equation}
  
  \item Un proceso de integración: El error recibido se suma en una variable de acumulación. Esta integra la medida de error actual, junto con todas las anteriores recibidas según la ecuación~\ref{eq:I}. El resultado es multiplicado por una constante de integración. El objetivo de esta componente, es eliminar error estacionario inalcanzable para el control proporcional. Una vez regulado el valor de la constante proporcional, ocurre que cierto error sigue presente. Este error se suma a sí mismo en cada ejecución del bucle, de tal manera que la acumulación crece lo suficiente como para que se produzca una respuesta sobre los actuadores, capaz de corregirlo. Se puede deducir que una vez corregido en un caso idea, el valor del acumulador dejaría de variar.
	\begin{equation}
		I[n] = Ki \sum_{0}^{n} e[n]
	\label{eq:I}
	\end{equation}
  
  \item Un proceso de derivación: El error previamente almacenado se resta al error de este instante generando la componente derivativa de la ecuación~\ref{eq:D}. El resultado es multiplicado por una constante de derivación. Los dos bucles anteriores tienen el objetivo de corregir el error. En el desarrollo de su tarea, existe la posibilidad de que el sistema oscile. La componente proporcional puede ajustarse para trabajar fuera del régimen de sobreoscilación, pero esto no ocurre con la componente integral, la cual por definición genera un retardo en la respuesta de los actuadores que produce oscilación. Esta puede ser tan pequeña que se vuelva imperceptible, de no ser así, la componente derivativa puede ayudar a minimizar las oscilaciones. Ya que calcula la derivada del error, cuanto este cambia bruscamente, por ejemplo cuando el sistema se acerca rápidamente a la posición de la consigna, la derivada en el tiempo también crecerá, pero en sentido contrario. De tal manera que la componente derivativa ayudará entonces a frenar el sistema, dotando al controlador de un grado de suavidad en el acercamiento hacia el error. Esto disminuye las oscilaciones, por tanto se puede deducir que esta componente resultará en cero en caso de un sistema ideal sin oscilaciones, ya que el error no variaría.
	\begin{equation}
		D[n] = Kd \cdot (e[n]-e[n-1])
	\label{eq:D}
	\end{equation}
  
\end{itemize}

El resultado de los 3 procesos previos se suma en una única señal de error construyendo la señal u(t) como se muestra en la Figura~\ref{fig:PID_Controller}.

\begin{figure}[h]
	\centering
	\includegraphics[]{Imagenes/PID_Figure.png}
	%\includegraphics[width=12cm, keepaspectratio]{Imagenes/Yaw-pitch-roll-Quadcopter.png}
	\caption{Esquema de un controlador PID}
	\label{fig:PID_Controller}
\end{figure}

El resultado de la suma de la Ecuación~\ref{eq:pid} será la variable usada para tratar de corregir el error existente. Es decir, será la variable a entregar a los distintos actuadores del sistema, dependiendo de en que parte se encuentre el PID ejecutado.

\begin{equation}
	u[n] = P[n] + I[n]+D[n]
\label{eq:pid}
\end{equation}









\begin{comment}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% APÉNDICE(S) %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\cleardoublepage
%\appendix
%\chapter{Manual de usuario}
%\label{app:manual}

%Esto es un apéndice.
%Si has creado una aplicación, siempre viene bien tener un manual de usuario.
%Pues ponlo aquí.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BIBLIOGRAFIA %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage

% Las siguientes dos instrucciones es todo lo que necesitas
% para incluir las citas en la memoria
\bibliographystyle{abbrv}
\bibliography{memoria}  % memoria.bib es el nombre del fichero que contiene
% las referencias bibliográficas. Abre ese fichero y mira el formato que tiene,
% que se conoce como BibTeX. Hay muchos sitios que exportan referencias en
% formato BibTeX. Prueba a buscar en http://scholar.google.com por referencias
% y verás que lo puedes hacer de manera sencilla.
% Más información: 
% http://texblog.org/2014/04/22/using-google-scholar-to-download-bibtex-citations/

\begin{itemize}
  \item 
  
  \item 
  
  \item 
  
  \item 
\end{itemize}

\begin{figure}[h]
	\centering
	\includegraphics[width=5cm, keepaspectratio]{Imagenes/giro.png}
	\caption{Error de rotación}
	\label{fig:Drone_error}
\end{figure}

Figura~\ref{fig:GS_desc}

\end{comment}


\end{document}
